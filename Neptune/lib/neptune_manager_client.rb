#!/usr/bin/ruby -w
# Programmer: Chris Bunch


require 'openssl'
require 'soap/rpc/driver'
require 'timeout'


# Sometimes SOAP calls take a long time if large amounts of data are being
# sent over the network: for this first version we don't want these calls to
# endlessly timeout and retry, so as a hack, just don't let them timeout.
# The next version should replace this and properly timeout and not use
# long calls unless necessary.
NO_TIMEOUT = -1


RETRY_ON_FAIL = true


ABORT_ON_FAIL = false


# A client that uses SOAP messages to communicate with the underlying cloud
# platform (here, AppScale). This client is similar to that used in the AppScale
# Tools, but with non-Neptune SOAP calls removed.
class NeptuneManagerClient


  SERVER_PORT = 17445


  # The SOAP client that we use to communicate with the NeptuneManager.
  attr_accessor :conn
      

  # The IP address of the NeptuneManager that we will be connecting to.
  attr_accessor :ip
            

  # The secret string that is used to authenticate this client with
  # NeptuneManagers. It is initially generated by appscale-run-instances and can
  # be found on the machine that ran that tool, or on any AppScale machine.
  attr_accessor :secret


  # A constructor that requires both the IP address of the machine to communicate
  # with as well as the secret (string) needed to perform communication.
  # NeptuneManagers will reject SOAP calls if this secret (basically a password)
  # is not present - it can be found in the user's .appscale directory, and a
  # helper method is usually present to fetch this for us.
  def initialize(ip, secret)
    @ip = ip
    @secret = secret
    
    @conn = SOAP::RPC::Driver.new("https://#{@ip}:#{SERVER_PORT}")
    @conn.add_method("get_queues_in_use", "secret")
  end


  # A helper method that makes SOAP calls for us. This method is mainly here to
  # reduce code duplication: all SOAP calls expect a certain timeout and can
  # tolerate certain exceptions, so we consolidate this code into this method.
  # Here, the caller specifies the timeout for the SOAP call (or NO_TIMEOUT
  # if an infinite timeout is required) as well as whether the call should
  # be retried in the face of exceptions. Exceptions can occur if the machine
  # is not yet running or is too busy to handle the request, so these exceptions
  # are automatically retried regardless of the retry value. Typically
  # callers set this to false to catch 'Connection Refused' exceptions or
  # the like. Finally, the caller must provide a block of
  # code that indicates the SOAP call to make: this is really all that differs
  # between the calling methods. The result of the block is returned to the
  # caller. 
  def make_call(time, retry_on_except, callr, ok_to_fail=false)
    refused_count = 0
    max = 5

    begin
      Timeout::timeout(time) {
        yield if block_given?
      }
    rescue Errno::ECONNREFUSED, Errno::EHOSTUNREACH
      if refused_count > max
        return false if ok_to_fail
        raise Exception.new("Connection was refused. Is the NeptuneManager running?")
      else
        refused_count += 1
        Kernel.sleep(1)
        retry
      end
    rescue Timeout::Error
      Kernel.puts("Saw a Timeout Error")
      if ok_to_fail
        return false
      else
        Kernel.sleep(1)
        retry
      end
    rescue OpenSSL::SSL::SSLError, NotImplementedError, Errno::EPIPE, Errno::ECONNRESET
      Kernel.puts("Saw a transient error")
      Kernel.sleep(1)
      retry
    rescue Exception => except
      trace = except.backtrace.join("\n")
      Kernel.puts("Saw an Exception of class #{except.class}, with trace: " +
        trace)
      if retry_on_except
        retry
      else
        raise Exception.new("[#{callr}] We saw an unexpected error of the " +
          "type #{except.class} with the following message:\n#{except}. " +
          "Trace is #{trace}")
      end
    end
  end


  def run_neptune_job(nodes, job_data)
    type = ""
    if job_data.class == Array
      type = job_data[0]["@type"]
    else
      type = job_data["@type"]
    end
    NeptuneManager.log("Neptune job type is #{type}")

    if NeptuneManager::JOB_LIST.include?(type)
      method_to_call = "#{type}_run_job"
      @conn.add_method(method_to_call, "nodes", "jobs", "secret")
      make_call(30, RETRY_ON_FAIL, "run_neptune_job") { 
        @conn.send(method_to_call.to_sym, nodes, job_data, @secret) 
      }
    else
      not_supported_message = "The job type you specified, '#{type}', is " +
       "not supported. Supported jobs are #{NeptuneManager::JOB_LIST.join(', ')}."
      raise Exception.new(not_supported_message)
    end
  end


  def get_queues_in_use()
    make_call(NO_TIMEOUT, RETRY_ON_FAIL, "get_queues_in_use") { 
      @conn.get_queues_in_use(@secret)
    }
  end
end

