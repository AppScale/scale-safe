<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class NeptuneManager - RDoc Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>Neptune/neptune_manager.rb
    <li>Neptune/lib/job_types/mpi_helper.rb
    <li>Neptune/lib/job_types/appscale_helper.rb
    <li>Neptune/lib/job_types/babel_helper.rb
    <li>Neptune/lib/job_types/mapreduce_helper.rb
    <li>Neptune/lib/job_types/cicero_helper.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link"><a href="Object.html">Object</a>
  
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-c-cleanup">::cleanup</a>
    
    <li><a href="#method-c-convert_location_array_to_class">::convert_location_array_to_class</a>
    
    <li><a href="#method-c-convert_location_class_to_array">::convert_location_class_to_array</a>
    
    <li><a href="#method-c-copy_code_and_inputs_to_dir">::copy_code_and_inputs_to_dir</a>
    
    <li><a href="#method-c-copy_code_to_dir">::copy_code_to_dir</a>
    
    <li><a href="#method-c-copy_file_to_dir">::copy_file_to_dir</a>
    
    <li><a href="#method-c-copy_inputs_to_dir">::copy_inputs_to_dir</a>
    
    <li><a href="#method-c-create_temp_dir">::create_temp_dir</a>
    
    <li><a href="#method-c-is_storage_location-3F">::is_storage_location?</a>
    
    <li><a href="#method-c-log">::log</a>
    
    <li><a href="#method-c-neptune_parse_creds">::neptune_parse_creds</a>
    
    <li><a href="#method-c-new">::new</a>
    
    <li><a href="#method-c-run_code">::run_code</a>
    
    <li><a href="#method-c-save_output">::save_output</a>
    
    <li><a href="#method-c-write_babel_outputs">::write_babel_outputs</a>
    
    <li><a href="#method-i-acquire_nodes">#acquire_nodes</a>
    
    <li><a href="#method-i-acquire_nodes_for_cloud">#acquire_nodes_for_cloud</a>
    
    <li><a href="#method-i-add_nodes">#add_nodes</a>
    
    <li><a href="#method-i-add_roles_and_wait">#add_roles_and_wait</a>
    
    <li><a href="#method-i-add_timing_info">#add_timing_info</a>
    
    <li><a href="#method-i-appscale_run_job">#appscale_run_job</a>
    
    <li><a href="#method-i-babel_run_job">#babel_run_job</a>
    
    <li><a href="#method-i-can_run_job">#can_run_job</a>
    
    <li><a href="#method-i-can_run_jobs_in_parallel-3F">#can_run_jobs_in_parallel?</a>
    
    <li><a href="#method-i-cicero_run_job">#cicero_run_job</a>
    
    <li><a href="#method-i-cleanup_code">#cleanup_code</a>
    
    <li><a href="#method-i-compile_code">#compile_code</a>
    
    <li><a href="#method-i-copy_from_shadow">#copy_from_shadow</a>
    
    <li><a href="#method-i-dispatch_jobs">#dispatch_jobs</a>
    
    <li><a href="#method-i-does_file_exist">#does_file_exist</a>
    
    <li><a href="#method-i-execute_multiple_tasks">#execute_multiple_tasks</a>
    
    <li><a href="#method-i-find_neighbors">#find_neighbors</a>
    
    <li><a href="#method-i-find_open_nodes">#find_open_nodes</a>
    
    <li><a href="#method-i-get_acl">#get_acl</a>
    
    <li><a href="#method-i-get_engines_for_creds">#get_engines_for_creds</a>
    
    <li><a href="#method-i-get_job_data">#get_job_data</a>
    
    <li><a href="#method-i-get_job_name">#get_job_name</a>
    
    <li><a href="#method-i-get_length_of_all_queues">#get_length_of_all_queues</a>
    
    <li><a href="#method-i-get_lock_file_path">#get_lock_file_path</a>
    
    <li><a href="#method-i-get_n_items_of_work">#get_n_items_of_work</a>
    
    <li><a href="#method-i-get_node_roles">#get_node_roles</a>
    
    <li><a href="#method-i-get_node_with_role">#get_node_with_role</a>
    
    <li><a href="#method-i-get_output">#get_output</a>
    
    <li><a href="#method-i-get_queues_from_shadow">#get_queues_from_shadow</a>
    
    <li><a href="#method-i-get_queues_in_use">#get_queues_in_use</a>
    
    <li><a href="#method-i-get_seed_vals">#get_seed_vals</a>
    
    <li><a href="#method-i-get_supported_babel_engines">#get_supported_babel_engines</a>
    
    <li><a href="#method-i-has_all_required_params-3F">#has_all_required_params?</a>
    
    <li><a href="#method-i-initialize_zookeeper_connection">#initialize_zookeeper_connection</a>
    
    <li><a href="#method-i-is_cloud-3F">#is_cloud?</a>
    
    <li><a href="#method-i-is_hybrid_cloud-3F">#is_hybrid_cloud?</a>
    
    <li><a href="#method-i-is_job_running">#is_job_running</a>
    
    <li><a href="#method-i-lock_file_exists-3F">#lock_file_exists?</a>
    
    <li><a href="#method-i-manage_virtual_machines">#manage_virtual_machines</a>
    
    <li><a href="#method-i-mapreduce_run_job">#mapreduce_run_job</a>
    
    <li><a href="#method-i-mpi_run_job">#mpi_run_job</a>
    
    <li><a href="#method-i-my_node">#my_node</a>
    
    <li><a href="#method-i-optimal_nodes">#optimal_nodes</a>
    
    <li><a href="#method-i-optimal_nodes_hill_climbing">#optimal_nodes_hill_climbing</a>
    
    <li><a href="#method-i-put_input">#put_input</a>
    
    <li><a href="#method-i-remove_lock_file">#remove_lock_file</a>
    
    <li><a href="#method-i-remove_roles">#remove_roles</a>
    
    <li><a href="#method-i-run_job_on_master">#run_job_on_master</a>
    
    <li><a href="#method-i-run_jobs_in_parallel">#run_jobs_in_parallel</a>
    
    <li><a href="#method-i-run_jobs_in_serial">#run_jobs_in_serial</a>
    
    <li><a href="#method-i-run_or_delegate_tasks">#run_or_delegate_tasks</a>
    
    <li><a href="#method-i-run_task">#run_task</a>
    
    <li><a href="#method-i-run_via_engine">#run_via_engine</a>
    
    <li><a href="#method-i-run_via_executor">#run_via_executor</a>
    
    <li><a href="#method-i-set_acl">#set_acl</a>
    
    <li><a href="#method-i-spawn_babel_slaves">#spawn_babel_slaves</a>
    
    <li><a href="#method-i-spawn_nodes_for_neptune-3F">#spawn_nodes_for_neptune?</a>
    
    <li><a href="#method-i-start">#start</a>
    
    <li><a href="#method-i-start_babel_master">#start_babel_master</a>
    
    <li><a href="#method-i-start_babel_slave">#start_babel_slave</a>
    
    <li><a href="#method-i-start_job">#start_job</a>
    
    <li><a href="#method-i-start_job_roles">#start_job_roles</a>
    
    <li><a href="#method-i-stop_babel_master">#stop_babel_master</a>
    
    <li><a href="#method-i-stop_babel_slave">#stop_babel_slave</a>
    
    <li><a href="#method-i-stop_job_roles">#stop_job_roles</a>
    
    <li><a href="#method-i-touch_lock_file">#touch_lock_file</a>
    
    <li><a href="#method-i-uncompress_file">#uncompress_file</a>
    
    <li><a href="#method-i-valid_secret-3F">#valid_secret?</a>
    
    <li><a href="#method-i-validate_environment">#validate_environment</a>
    
    <li><a href="#method-i-wait_for_allotted_time">#wait_for_allotted_time</a>
    
    <li><a href="#method-i-write_job_output">#write_job_output</a>
    
    <li><a href="#method-i-write_job_output_handler">#write_job_output_handler</a>
    
    <li><a href="#method-i-write_job_output_str">#write_job_output_str</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    
    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./AppControllerClient.html">AppControllerClient</a>
  
    <li><a href="./BadConfigurationException.html">BadConfigurationException</a>
  
    <li><a href="./Datastore.html">Datastore</a>
  
    <li><a href="./DatastoreFactory.html">DatastoreFactory</a>
  
    <li><a href="./DatastoreRepo.html">DatastoreRepo</a>
  
    <li><a href="./DatastoreRepoOnAppEngine.html">DatastoreRepoOnAppEngine</a>
  
    <li><a href="./DatastoreRepoOnAppScale.html">DatastoreRepoOnAppScale</a>
  
    <li><a href="./DatastoreS3.html">DatastoreS3</a>
  
    <li><a href="./DatastoreWAZStorage.html">DatastoreWAZStorage</a>
  
    <li><a href="./DjinnJobData.html">DjinnJobData</a>
  
    <li><a href="./EngineFactory.html">EngineFactory</a>
  
    <li><a href="./FailedZooKeeperOperationException.html">FailedZooKeeperOperationException</a>
  
    <li><a href="./GoogleAppEnginePullQueue.html">GoogleAppEnginePullQueue</a>
  
    <li><a href="./GoogleAppEnginePushQueue.html">GoogleAppEnginePushQueue</a>
  
    <li><a href="./HelperFunctions.html">HelperFunctions</a>
  
    <li><a href="./InfrastructureManagerClient.html">InfrastructureManagerClient</a>
  
    <li><a href="./JSONClient.html">JSONClient</a>
  
    <li><a href="./NeptuneJobData.html">NeptuneJobData</a>
  
    <li><a href="./NeptuneManager.html">NeptuneManager</a>
  
    <li><a href="./NeptuneManagerClient.html">NeptuneManagerClient</a>
  
    <li><a href="./NeptuneManagerServer.html">NeptuneManagerServer</a>
  
    <li><a href="./Object.html">Object</a>
  
    <li><a href="./QueueFactory.html">QueueFactory</a>
  
    <li><a href="./TaskEngine.html">TaskEngine</a>
  
    <li><a href="./TaskEngineAppScale.html">TaskEngineAppScale</a>
  
    <li><a href="./TaskEngineGoogleAppEngine.html">TaskEngineGoogleAppEngine</a>
  
    <li><a href="./TaskQueue.html">TaskQueue</a>
  
    <li><a href="./TaskQueueAzureQueue.html">TaskQueueAzureQueue</a>
  
    <li><a href="./TaskQueueGoogleAppEngine.html">TaskQueueGoogleAppEngine</a>
  
    <li><a href="./TaskQueueRabbitMQ.html">TaskQueueRabbitMQ</a>
  
    <li><a href="./TaskQueueSQS.html">TaskQueueSQS</a>
  
    <li><a href="./UserAppClient.html">UserAppClient</a>
  
    <li><a href="./ZKInterface.html">ZKInterface</a>
  
    <li><a href="./ZooKeeperLockException.html">ZooKeeperLockException</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class NeptuneManager</h1>

  <div id="description" class="description">
    
<p>things to fix</p>

<p>remove all dead code from AppController/helperfunctions</p>

<p>remove all dead code from Neptune/helperfunctions</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="ALLOWED_STORAGE_TYPES">ALLOWED_STORAGE_TYPES
        
        <dd class="description">
        
      
        <dt id="AMAZON_CREDENTIALS">AMAZON_CREDENTIALS
        
        <dd class="description"><p>When executing over AppScale with Amazon credentials, we can utilize 
Amazon SQS (Simple Queue Service) as a queue and use Executor to execute
tasks.</p>
        
      
        <dt id="AMAZON_ENGINES">AMAZON_ENGINES
        
        <dd class="description">
        
      
        <dt id="AZURE_CREDENTIALS">AZURE_CREDENTIALS
        
        <dd class="description"><p>When executing over AppScale with Azure credentials, we can utilize the
Windows Azure Queue Service as a queue and use Executor to execute tasks.</p>
        
      
        <dt id="AZURE_ENGINES">AZURE_ENGINES
        
        <dd class="description">
        
      
        <dt id="BAD_SECRET_MSG">BAD_SECRET_MSG
        
        <dd class="description"><p>The string that should be returned to the caller if they call a publicly
exposed SOAP method but provide an incorrect secret.</p>
        
      
        <dt id="BAD_TYPE_MSG">BAD_TYPE_MSG
        
        <dd class="description">
        
      
        <dt id="DEBUG">DEBUG
        
        <dd class="description"><p>This debug flag is used to keep the user’s code on the local filesystem,
which can be useful to debug why code did not run successfully.</p>
        
      
        <dt id="GOOGLE_CREDENTIALS">GOOGLE_CREDENTIALS
        
        <dd class="description"><p>When executing over AppScale with Google credentials, we can utilize Google
App Engine’s push queues as the queue and task engine or Google App
Engine’s pull queues as the queue and Executor to execute tasks. Since
our pull queue support is done via an App Engine app, the same credentials
will work for pull queues as for push queues (minus @function).</p>
        
      
        <dt id="GOOGLE_ENGINES">GOOGLE_ENGINES
        
        <dd class="description">
        
      
        <dt id="HADOOP_DIR">HADOOP_DIR
        
        <dd class="description">
        
      
        <dt id="HADOOP_EXECUTABLE">HADOOP_EXECUTABLE
        
        <dd class="description">
        
      
        <dt id="HADOOP_STREAMING_JAR">HADOOP_STREAMING_JAR
        
        <dd class="description">
        
      
        <dt id="HADOOP_VERSION">HADOOP_VERSION
        
        <dd class="description">
        
      
        <dt id="INFINITY">INFINITY
        
        <dd class="description">
        
      
        <dt id="INSTANCE_CPU_INFO">INSTANCE_CPU_INFO
        
        <dd class="description"><p>A mapping of Amazon EC2 instance types that maps instance types to the
number of cores they have. TODO(cgb): Should we eventually include memory /
disk info here?</p>
        
      
        <dt id="INTERNAL_ENGINES">INTERNAL_ENGINES
        
        <dd class="description"><p>When executing over AppScale resources only, we can utilize RabbitMQ as a
queue and use Executor, our task engine, or we can make the app into an App
Engine app and exeucte it via the App Engine Task Queue API.</p>
        
      
        <dt id="JOB_IN_PROGRESS">JOB_IN_PROGRESS
        
        <dd class="description">
        
      
        <dt id="JOB_IS_RUNNING">JOB_IS_RUNNING
        
        <dd class="description">
        
      
        <dt id="JOB_LIST">JOB_LIST
        
        <dd class="description">
        
      
        <dt id="MAX_IDLE_TIME">MAX_IDLE_TIME
        
        <dd class="description"><p>The amount of time that we should hold the babel_slave role for, even if we
receive no tasks. Dynamically adding and removing this role frees it up to
take on other roles for fault tolerance purposes, and we keep the value 
non-trivially high because starting and stopping RabbitMQ (which we always
start for babel_slave since rabbitmq is one of the possible backends) can
take a while. TODO(cgb): Maybe only start rabbitmq if we get an item from
the queue that specifies it should be used?</p>
        
      
        <dt id="MISSING_PARAM">MISSING_PARAM
        
        <dd class="description">
        
      
        <dt id="MPD_HOSTS">MPD_HOSTS
        
        <dd class="description">
        
      
        <dt id="MPI_OUTPUT">MPI_OUTPUT
        
        <dd class="description">
        
      
        <dt id="MULTI_NODE_COMPUTE_JOBS">MULTI_NODE_COMPUTE_JOBS
        
        <dd class="description">
        
      
        <dt id="NONCOMPUTE_JOBS">NONCOMPUTE_JOBS
        
        <dd class="description">
        
      
        <dt id="NOT_QUITE_AN_HOUR">NOT_QUITE_AN_HOUR
        
        <dd class="description">
        
      
        <dt id="NO_INPUT_NEEDED">NO_INPUT_NEEDED
        
        <dd class="description">
        
      
        <dt id="NO_NODES_NEEDED">NO_NODES_NEEDED
        
        <dd class="description">
        
      
        <dt id="RUN_JOBS_IN_PARALLEL">RUN_JOBS_IN_PARALLEL
        
        <dd class="description">
        
      
        <dt id="RUN_JOBS_IN_SERIAL">RUN_JOBS_IN_SERIAL
        
        <dd class="description">
        
      
        <dt id="RUN_LOCALLY">RUN_LOCALLY
        
        <dd class="description"><p>Constants that are used to indicate which engine runs a task.</p>
        
      
        <dt id="RUN_VIA_EXECUTOR">RUN_VIA_EXECUTOR
        
        <dd class="description">
        
      
        <dt id="RUN_VIA_REMOTE_ENGINE">RUN_VIA_REMOTE_ENGINE
        
        <dd class="description">
        
      
        <dt id="SERVER_PORT">SERVER_PORT
        
        <dd class="description"><p>The port that the <a href="NeptuneManager.html">NeptuneManager</a> runs on,
by default.</p>
        
      
        <dt id="SINGLE_NODE_COMPUTE_JOBS">SINGLE_NODE_COMPUTE_JOBS
        
        <dd class="description">
        
      
        <dt id="STARTED_SUCCESSFULLY">STARTED_SUCCESSFULLY
        
        <dd class="description">
        
      
        <dt id="STORAGE_PARAM_REGEX">STORAGE_PARAM_REGEX
        
        <dd class="description"><p>Files stored in remote datastores are referenced in a POSIX-like fashion:
/bucket/file refers to a file stored in S3, with the named bucket and file.</p>
        
      
        <dt id="TIME_FOR_NEW_NODES_TO_GET_TASKS">TIME_FOR_NEW_NODES_TO_GET_TASKS
        
        <dd class="description">
        
      
        <dt id="TIME_TO_WAIT_FOR_NEW_TASKS">TIME_TO_WAIT_FOR_NEW_TASKS
        
        <dd class="description"><p>Constants that are used to indicate how long a babel_master node should
sleep for if there are no tasks to schedule, and how long to sleep for if
new babel_slaves have been spawned and need time to fetch tasks off of
queues.</p>
        
      
        <dt id="URL_REGEX">URL_REGEX
        
        <dd class="description">
        
      
        <dt id="ZK_LOCATIONS_FILE">ZK_LOCATIONS_FILE
        
        <dd class="description">
        
      
      </dl>
    </section>
    

    
    <!-- Attributes -->
    <section id="attribute-method-details" class="method-section section">
      <h3 class="section-header">Attributes</h3>

      
      <div id="attribute-i-jobs" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">jobs</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-queues_to_read" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">queues_to_read</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>An Array that contains the credentials for each pull queue that Babel tasks
can be stored in.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-secret" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">secret</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The shared secret that is used to authenticate remote callers.</p>
        
        </div>
      </div>
      
    </section><!-- attribute-method-details -->
    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-cleanup" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">cleanup</span><span
            class="method-args">(dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="cleanup-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 576</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cleanup</span>(<span class="ruby-identifier">dir</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Cleaning up directory #{dir}&quot;</span>)
  <span class="ruby-comment"># don't clean up if we want to debug the system</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">DEBUG</span>
  <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_rf</span>(<span class="ruby-identifier">dir</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- cleanup-source -->
          
        </div>

        

        
      </div><!-- cleanup-method -->

    
      <div id="method-c-convert_location_array_to_class" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">convert_location_array_to_class</span><span
            class="method-args">(nodes, keyname)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="convert_location_array_to_class-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1126</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">convert_location_array_to_class</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">keyname</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Keyname is of class #{keyname.class}&quot;</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Keyname is #{keyname}&quot;</span>)

  <span class="ruby-identifier">array_of_nodes</span> = []
  <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">converted</span> = <span class="ruby-constant">DjinnJobData</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">keyname</span>)
    <span class="ruby-identifier">array_of_nodes</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">converted</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Adding data &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">converted</span>.<span class="ruby-identifier">to_s</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">array_of_nodes</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- convert_location_array_to_class-source -->
          
        </div>

        

        
      </div><!-- convert_location_array_to_class-method -->

    
      <div id="method-c-convert_location_class_to_array" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">convert_location_class_to_array</span><span
            class="method-args">(djinn_locations)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="convert_location_class_to_array-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1141</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">convert_location_class_to_array</span>(<span class="ruby-identifier">djinn_locations</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">djinn_locations</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">Array</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Exception</span>, <span class="ruby-string">&quot;Locations should be an array&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">djinn_loc_array</span> = []
  <span class="ruby-identifier">djinn_locations</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">location</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">djinn_loc_array</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">location</span>.<span class="ruby-identifier">serialize</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Serializing data &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">location</span>.<span class="ruby-identifier">serialize</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">djinn_loc_array</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- convert_location_class_to_array-source -->
          
        </div>

        

        
      </div><!-- convert_location_class_to_array-method -->

    
      <div id="method-c-copy_code_and_inputs_to_dir" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">copy_code_and_inputs_to_dir</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="copy_code_and_inputs_to_dir-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 402</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copy_code_and_inputs_to_dir</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-identifier">input_storage_start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">copy_code_to_dir</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">copy_inputs_to_dir</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-identifier">input_storage_end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'input_storage_time'</span>] = <span class="ruby-identifier">input_storage_end_time</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">input_storage_start_time</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- copy_code_and_inputs_to_dir-source -->
          
        </div>

        

        
      </div><!-- copy_code_and_inputs_to_dir-method -->

    
      <div id="method-c-copy_code_to_dir" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">copy_code_to_dir</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="copy_code_to_dir-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 410</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copy_code_to_dir</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_storage_location?</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>])
    <span class="ruby-identifier">abort</span>(<span class="ruby-node">&quot;The given code, #{job_data['@code']}, is not something we can fetch&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;old code is #{job_data['@code']}&quot;</span>)
  <span class="ruby-identifier">local_folder</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copy_file_to_dir</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>]), <span class="ruby-identifier">dir</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>] = <span class="ruby-identifier">local_folder</span> <span class="ruby-operator">+</span> <span class="ruby-string">'/'</span> <span class="ruby-operator">+</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>])

  <span class="ruby-comment"># If the code isn't going to be executed by a different program (e.g., python)</span>
  <span class="ruby-comment"># then we need to make it executable</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@executable&quot;</span>].<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@executable&quot;</span>].<span class="ruby-identifier">empty?</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;making code executable&quot;</span>)
    <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-node">&quot;chmod +x #{job_data['@code']}&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;new code is #{job_data['@code']}&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- copy_code_to_dir-source -->
          
        </div>

        

        
      </div><!-- copy_code_to_dir-method -->

    
      <div id="method-c-copy_file_to_dir" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">copy_file_to_dir</span><span
            class="method-args">(remote, local, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="copy_file_to_dir-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 451</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copy_file_to_dir</span>(<span class="ruby-identifier">remote</span>, <span class="ruby-identifier">local</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">bucket</span>, <span class="ruby-identifier">file</span> = <span class="ruby-constant">DatastoreS3</span>.<span class="ruby-identifier">parse_s3_key</span>(<span class="ruby-identifier">remote</span>)
  <span class="ruby-identifier">remote_dir</span> = <span class="ruby-identifier">file</span>
  <span class="ruby-identifier">local_file</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-identifier">local</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;/&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">remote_dir</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;downloading remote file #{remote} to local location #{local_file}&quot;</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;bucket is #{bucket}, file is #{file}&quot;</span>)

  <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">get_output_and_save_to_fs</span>(<span class="ruby-identifier">remote</span>, <span class="ruby-identifier">local</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">local_file</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- copy_file_to_dir-source -->
          
        </div>

        

        
      </div><!-- copy_file_to_dir-method -->

    
      <div id="method-c-copy_inputs_to_dir" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">copy_inputs_to_dir</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="copy_inputs_to_dir-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 431</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copy_inputs_to_dir</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@argv'</span>].<span class="ruby-identifier">class</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">Array</span>

  <span class="ruby-identifier">new_argv</span> = []

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;old argv is #{job_data['@argv'].join(' ')}&quot;</span>)
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@argv'</span>].<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">arg</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_storage_location?</span>(<span class="ruby-identifier">arg</span>)
      <span class="ruby-identifier">new_argv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">copy_file_to_dir</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">dir</span>, <span class="ruby-identifier">job_data</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">new_argv</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">arg</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@argv'</span>] = <span class="ruby-identifier">new_argv</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;new argv is #{job_data['@argv'].join(' ')}&quot;</span>)
  <span class="ruby-keyword">return</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- copy_inputs_to_dir-source -->
          
        </div>

        

        
      </div><!-- copy_inputs_to_dir-method -->

    
      <div id="method-c-create_temp_dir" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">create_temp_dir</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="create_temp_dir-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 395</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">create_temp_dir</span>()
  <span class="ruby-identifier">dir</span> = <span class="ruby-node">&quot;/tmp/babel-#{rand(10000)}/&quot;</span>
  <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">mkdir_p</span>(<span class="ruby-identifier">dir</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">dir</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- create_temp_dir-source -->
          
        </div>

        

        
      </div><!-- create_temp_dir-method -->

    
      <div id="method-c-is_storage_location-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_storage_location?</span><span
            class="method-args">(file)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="is_storage_location-3F-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 584</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_storage_location?</span>(<span class="ruby-identifier">file</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">STORAGE_PARAM_REGEX</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">file</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_storage_location-3F-source -->
          
        </div>

        

        
      </div><!-- is_storage_location-3F-method -->

    
      <div id="method-c-log" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">log</span><span
            class="method-args">(msg)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="log-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 131</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-identifier">msg</span>)
  <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">puts</span>(<span class="ruby-identifier">msg</span>)
  <span class="ruby-constant">STDOUT</span>.<span class="ruby-identifier">flush</span>()
<span class="ruby-keyword">end</span></pre>
          </div><!-- log-source -->
          
        </div>

        

        
      </div><!-- log-method -->

    
      <div id="method-c-neptune_parse_creds" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">neptune_parse_creds</span><span
            class="method-args">(storage, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="neptune_parse_creds-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1105</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">neptune_parse_creds</span>(<span class="ruby-identifier">storage</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">creds</span> = {}

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">storage</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;s3&quot;</span>
    [<span class="ruby-string">'EC2_ACCESS_KEY'</span>, <span class="ruby-string">'EC2_SECRET_KEY'</span>, <span class="ruby-string">'S3_URL'</span>].<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">creds</span>[<span class="ruby-identifier">item</span>] = <span class="ruby-identifier">job_data</span>[<span class="ruby-node">&quot;@#{item}&quot;</span>]
    }
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">creds</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- neptune_parse_creds-source -->
          
        </div>

        

        
      </div><!-- neptune_parse_creds-method -->

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>TODO(cgb): back these up to zookeeper and restore from there as needed</p>
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>()
  <span class="ruby-ivar">@secret</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>()
  <span class="ruby-ivar">@queues_to_read</span> = []
  <span class="ruby-ivar">@jobs</span> = {}
<span class="ruby-keyword">end</span></pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
      <div id="method-c-run_code" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_code</span><span
            class="method-args">(job_data, dir)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="run_code-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 464</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">run_code</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-identifier">filename_to_exec</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>]

  <span class="ruby-identifier">executable</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@executable'</span>] <span class="ruby-operator">||</span> <span class="ruby-string">&quot;&quot;</span>

  <span class="ruby-comment"># If the user specifies an argv to pass to the code to exec, be sure to</span>
  <span class="ruby-comment"># capture it and pass it along</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@argv&quot;</span>]
    <span class="ruby-identifier">argv</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@argv&quot;</span>].<span class="ruby-identifier">join</span>(<span class="ruby-string">' '</span>)
    <span class="ruby-comment"># TODO(cgb): filter out colons and other things that malicious users could</span>
    <span class="ruby-comment"># use to hijack the system</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">argv</span> = <span class="ruby-string">&quot;&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">output_file</span> = <span class="ruby-node">&quot;#{dir}/stdout-#{HelperFunctions.get_random_alphanumeric()}&quot;</span>
  <span class="ruby-identifier">error_file</span> = <span class="ruby-node">&quot;#{dir}/stderr-#{HelperFunctions.get_random_alphanumeric()}&quot;</span>

  <span class="ruby-comment"># For most file types, we can use the full path when executing them. For</span>
  <span class="ruby-comment"># programs that run over the JVM (e.g., Java, Scala), we can't - we need </span>
  <span class="ruby-comment"># to change into the directory where the file is located and exec the file </span>
  <span class="ruby-comment"># from there.</span>
  <span class="ruby-comment"># TODO(cgb): Consider a job_data['@jvm_args'] option (with an array val)</span>
  <span class="ruby-comment"># that users can set to pass in arguments that we should pass to the JVM</span>
  <span class="ruby-comment"># we are about to run.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">executable</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;java&quot;</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">executable</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;scala&quot;</span>
    <span class="ruby-identifier">dir</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">filename_to_exec</span>)
    <span class="ruby-identifier">file</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">basename</span>(<span class="ruby-identifier">filename_to_exec</span>)
    <span class="ruby-identifier">exec_command</span> = <span class="ruby-node">&quot;cd #{dir}; #{executable} #{file} #{argv} 1&gt;#{output_file} 2&gt;#{error_file}&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">exec_command</span> = <span class="ruby-node">&quot;#{executable} #{filename_to_exec} #{argv} 1&gt;#{output_file} 2&gt;#{error_file}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
  <span class="ruby-identifier">ret_val</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-identifier">exec_command</span>)
  <span class="ruby-identifier">end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>

  <span class="ruby-identifier">total</span> = <span class="ruby-identifier">end_time</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">start_time</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Babel: Done running job!&quot;</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;TIMING: Took #{total} seconds&quot;</span>)

  <span class="ruby-comment"># Save some data about the task we just ran. At a high level, there are two</span>
  <span class="ruby-comment"># types of information we want to save: debugging information (in case the</span>
  <span class="ruby-comment"># task failed and the user needs to deduce why), and profiling information</span>
  <span class="ruby-comment"># (so the user can see how long their code took to run).</span>

  <span class="ruby-comment"># Add in debugging information.</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'command'</span>] = <span class="ruby-identifier">exec_command</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'return_value'</span>] = <span class="ruby-identifier">ret_val</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'cpu_info'</span>] = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-string">&quot;cat /proc/cpuinfo&quot;</span>)
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'mem_info'</span>] = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-string">&quot;cat /proc/meminfo&quot;</span>)
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'df_h'</span>] = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-string">&quot;df -h&quot;</span>)

  <span class="ruby-comment"># Add in profiling information, with all times converted to seconds since epoch.</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'start_time'</span>] = <span class="ruby-identifier">start_time</span>.<span class="ruby-identifier">to_i</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'end_time'</span>] = <span class="ruby-identifier">end_time</span>.<span class="ruby-identifier">to_i</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'total_execution_time'</span>] = <span class="ruby-identifier">total</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">output_file</span>, <span class="ruby-identifier">error_file</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_code-source -->
          
        </div>

        

        
      </div><!-- run_code-method -->

    
      <div id="method-c-save_output" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">save_output</span><span
            class="method-args">(remote_output, local_output, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="save_output-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 569</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">save_output</span>(<span class="ruby-identifier">remote_output</span>, <span class="ruby-identifier">local_output</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saving local output #{local_output} to remote location #{remote_output}&quot;</span>)
  <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">write_remote_file_from_local_file</span>(<span class="ruby-identifier">remote_output</span>, <span class="ruby-identifier">local_output</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- save_output-source -->
          
        </div>

        

        
      </div><!-- save_output-method -->

    
      <div id="method-c-write_babel_outputs" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write_babel_outputs</span><span
            class="method-args">(output, error, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Writes the stdout and stderr that a Babel task produces to the remote
datastore that the user has specified to use. We also automatically collect
some metadata about the task, so we write that to the datastore as well.</p>
          

          
          <div class="method-source-code" id="write_babel_outputs-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 529</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">write_babel_outputs</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">error</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)

  <span class="ruby-comment"># Write our stdout file</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saving stdout at #{output} to remote location&quot;</span> <span class="ruby-operator">+</span> 
    <span class="ruby-node">&quot; #{job_data['@output']}&quot;</span>)
  <span class="ruby-identifier">output_storage_start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
  <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">write_remote_file_from_local_file</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@output'</span>], <span class="ruby-identifier">output</span>)

  <span class="ruby-comment"># Write our stderr file</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saving stderr #{error} to remote location&quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot; #{job_data['@error']}&quot;</span>)
  <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">write_remote_file_from_local_file</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@error'</span>], <span class="ruby-identifier">error</span>)
  <span class="ruby-identifier">output_storage_end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
  <span class="ruby-identifier">total_output_time</span> = <span class="ruby-identifier">output_storage_end_time</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">output_storage_start_time</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'output_storage_time'</span>] = <span class="ruby-identifier">total_output_time</span>

  <span class="ruby-identifier">local_input_storage_time</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'time_to_store_inputs'</span>] <span class="ruby-operator">||</span> <span class="ruby-value">0.0</span>
  <span class="ruby-identifier">total_input_time</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'input_storage_time'</span>] <span class="ruby-operator">||</span> <span class="ruby-value">0.0</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'total_storage_time'</span>] = <span class="ruby-identifier">local_input_storage_time</span> <span class="ruby-operator">+</span> 
    <span class="ruby-identifier">total_input_time</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">total_output_time</span>

  <span class="ruby-identifier">end_of_task_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">to_f</span>
  <span class="ruby-identifier">start_of_task_time</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'received_task_at'</span>] <span class="ruby-operator">||</span> <span class="ruby-value">0.0</span>
  <span class="ruby-identifier">total_task_time</span> = <span class="ruby-identifier">end_of_task_time</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">start_of_task_time</span>
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'total_task_time'</span>] = <span class="ruby-identifier">total_task_time</span>

  <span class="ruby-comment"># Write our metadata info, which is not a file, but a hash we will turn to</span>
  <span class="ruby-comment"># a string via JSON</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saving metadata #{job_data['@metadata_info'].inspect} &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;to remote location #{job_data['@metadata']}&quot;</span>)
  <span class="ruby-identifier">metadata_file</span> = <span class="ruby-node">&quot;/tmp/metadata-#{HelperFunctions.get_random_alphanumeric()}&quot;</span>
  <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">write_file</span>(<span class="ruby-identifier">metadata_file</span>, 
    <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">dump</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>]))
  <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">write_remote_file_from_local_file</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata'</span>], 
    <span class="ruby-identifier">metadata_file</span>)
  <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_f</span>(<span class="ruby-identifier">metadata_file</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- write_babel_outputs-source -->
          
        </div>

        

        
      </div><!-- write_babel_outputs-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-acquire_nodes" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">acquire_nodes</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="acquire_nodes-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 725</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">acquire_nodes</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-comment"># for jobs where no nodes need to be acquired (e.g., concurrent but not</span>
  <span class="ruby-comment"># distributed programs), run them on the shadow node</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">NO_NODES_NEEDED</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>])
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;No nodes needed for job type [#{job_data['@type']}],&quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-string">&quot; not acquiring nodes&quot;</span>)
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">my_node</span>()]
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;acquiring nodes&quot;</span>)

  <span class="ruby-comment">#num_of_vms_needed = optimal_nodes_hill_climbing(job_data, &quot;performance&quot;)</span>
  <span class="ruby-identifier">nodes_needed</span> = <span class="ruby-identifier">optimal_nodes</span>(<span class="ruby-identifier">job_data</span>)

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;acquiring nodes for hybrid cloud neptune job&quot;</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes_needed</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Array</span>
    <span class="ruby-identifier">nodes_needed</span> = <span class="ruby-constant">Hash</span>[*<span class="ruby-identifier">nodes_needed</span>]
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;request received to spawn hybrid nodes: #{nodes_needed.inspect}&quot;</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">nodes_needed</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Fixnum</span>
    <span class="ruby-identifier">nodes_needed</span> = {<span class="ruby-string">&quot;cloud1&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">nodes_needed</span>}
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;nodes_needed was not the right class - should have been Array or Fixnum but was #{nodes_needed.class}&quot;</span>)
    <span class="ruby-comment"># TODO: find a way to reject the job here</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">nodes_to_use</span> = []

  <span class="ruby-identifier">nodes_needed</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">cloud</span>, <span class="ruby-identifier">nodes_to_acquire</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># nodes_to_acquire can either be an integer or a URL</span>
    <span class="ruby-comment"># if it's an integer, spawn up that many nodes</span>
    <span class="ruby-comment"># if it's a URL, it refers to a remote cloud resource we don't control</span>
    <span class="ruby-comment"># (e.g., Google App Engine), so skip it</span>

    <span class="ruby-comment"># in non-hybrid cloud runs, cloud1 will be the only cloud that specifies</span>
    <span class="ruby-comment"># an integer value</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes_to_acquire</span> <span class="ruby-operator">=~</span> <span class="ruby-constant">URL_REGEX</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;nodes to acquire for #{cloud} was a URL &quot;</span> <span class="ruby-operator">+</span> 
        <span class="ruby-node">&quot;[#{nodes_to_acquire}], so not spawning nodes&quot;</span>)
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;acquiring #{nodes_to_acquire} nodes for #{cloud}&quot;</span>)
    <span class="ruby-identifier">nodes_for_cloud</span> = <span class="ruby-identifier">find_open_nodes</span>(<span class="ruby-identifier">cloud</span>, <span class="ruby-identifier">nodes_to_acquire</span>, <span class="ruby-identifier">job_data</span>)
    <span class="ruby-identifier">nodes_to_use</span> = [<span class="ruby-identifier">nodes_to_use</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">nodes_for_cloud</span>].<span class="ruby-identifier">flatten</span>
    <span class="ruby-comment"># TODO: should check for failures acquiring nodes</span>
  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">nodes_to_use</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- acquire_nodes-source -->
          
        </div>

        

        
      </div><!-- acquire_nodes-method -->

    
      <div id="method-i-acquire_nodes_for_cloud" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">acquire_nodes_for_cloud</span><span
            class="method-args">(cloud_num, new_vms_needed, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="acquire_nodes_for_cloud-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 814</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">acquire_nodes_for_cloud</span>(<span class="ruby-identifier">cloud_num</span>, <span class="ruby-identifier">new_vms_needed</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_vms_needed</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">1</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;spawning up #{new_vms_needed} vms&quot;</span>)

  <span class="ruby-comment"># TODO(cgb): get creds</span>
  <span class="ruby-identifier">cloud</span> = <span class="ruby-node">&quot;cloud#{cloud_num}&quot;</span>
  <span class="ruby-identifier">imc</span> = <span class="ruby-constant">InfrastructureManagerClient</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@secret</span>)
  <span class="ruby-identifier">new_node_info</span> = <span class="ruby-identifier">imc</span>.<span class="ruby-identifier">spawn_vms</span>(<span class="ruby-identifier">new_vms_needed</span>, <span class="ruby-ivar">@creds</span>, <span class="ruby-string">&quot;open&quot;</span>, <span class="ruby-identifier">cloud</span>)
  <span class="ruby-identifier">add_nodes</span>(<span class="ruby-identifier">new_node_info</span>)
 
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;got all the vms i needed!&quot;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- acquire_nodes_for_cloud-source -->
          
        </div>

        

        
      </div><!-- acquire_nodes_for_cloud-method -->

    
      <div id="method-i-add_nodes" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_nodes</span><span
            class="method-args">(node_info)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_nodes-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 827</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">add_nodes</span>(<span class="ruby-identifier">node_info</span>)
  <span class="ruby-identifier">keyname</span> = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
  <span class="ruby-identifier">new_nodes</span> = <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">convert_location_array_to_class</span>(<span class="ruby-identifier">node_info</span>, <span class="ruby-identifier">keyname</span>)

  <span class="ruby-identifier">node_start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
  <span class="ruby-identifier">node_end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-operator">+</span> <span class="ruby-constant">NOT_QUITE_AN_HOUR</span>

  <span class="ruby-identifier">new_nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">set_time_info</span>(<span class="ruby-identifier">node_start_time</span>, <span class="ruby-identifier">node_end_time</span>)
  }

  <span class="ruby-ivar">@nodes</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">new_nodes</span>)
  <span class="ruby-ivar">@nodes_in_use</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">new_nodes</span>)
  <span class="ruby-identifier">initialize_nodes_in_parallel</span>(<span class="ruby-identifier">new_nodes</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- add_nodes-source -->
          
        </div>

        

        
      </div><!-- add_nodes-method -->

    
      <div id="method-i-add_roles_and_wait" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_roles_and_wait</span><span
            class="method-args">(nodes, roles)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_roles_and_wait-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 857</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">add_roles_and_wait</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">roles</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">add_roles</span>(<span class="ruby-identifier">roles</span>)
    <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">add_roles_to_node</span>(<span class="ruby-identifier">roles</span>, <span class="ruby-identifier">node</span>)
    <span class="ruby-identifier">acc</span> = <span class="ruby-constant">AppControllerClient</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">private_ip</span>, <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>)
    <span class="ruby-identifier">acc</span>.<span class="ruby-identifier">wait_for_node_to_be</span>(<span class="ruby-identifier">roles</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;[just added] node at #{node.private_ip} is now #{node.jobs.join(', ')}&quot;</span>)
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- add_roles_and_wait-source -->
          
        </div>

        

        
      </div><!-- add_roles_and_wait-method -->

    
      <div id="method-i-add_timing_info" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_timing_info</span><span
            class="method-args">(job_data, nodes_to_use, start_time, end_time)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="add_timing_info-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1075</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">add_timing_info</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">start_time</span>, <span class="ruby-identifier">end_time</span>)
  <span class="ruby-identifier">name</span> = <span class="ruby-identifier">get_job_name</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">num_nodes</span> = <span class="ruby-identifier">nodes_to_use</span>.<span class="ruby-identifier">length</span>
  <span class="ruby-identifier">this_job</span> = <span class="ruby-constant">NeptuneJobData</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">num_nodes</span>, <span class="ruby-identifier">start_time</span>, <span class="ruby-identifier">end_time</span>,
    <span class="ruby-string">&quot;m1.large&quot;</span>)  <span class="ruby-comment"># TODO(cgb): get the real instance type</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@jobs</span>[<span class="ruby-identifier">name</span>].<span class="ruby-identifier">nil?</span>
    <span class="ruby-ivar">@jobs</span>[<span class="ruby-identifier">name</span>] = [<span class="ruby-identifier">this_job</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@jobs</span>[<span class="ruby-identifier">name</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">this_job</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- add_timing_info-source -->
          
        </div>

        

        
      </div><!-- add_timing_info-method -->

    
      <div id="method-i-appscale_run_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">appscale_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="appscale_run_job-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/appscale_helper.rb, line 12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">appscale_run_job</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;appscale - run&quot;</span>)

  <span class="ruby-identifier">required_params</span> = <span class="ruby-node">%w{@time_needed_for @add_component}</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">has_all_required_params?</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">required_params</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-constant">MISSING_PARAM</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">wait_for_allotted_time</span>(<span class="ruby-identifier">job_data</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-constant">STARTED_SUCCESSFULLY</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- appscale_run_job-source -->
          
        </div>

        

        
      </div><!-- appscale_run_job-method -->

    
      <div id="method-i-babel_run_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">babel_run_job</span><span
            class="method-args">(nodes, jobs, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method is the spawning service for Babel - that is, it decides where 
tasks should be spawned. For now, we don’t intelligently decide where to
run tasks - we just run tasks where the user tells us to run them. Since
this method is accessible via SOAP, it has a time limit on its execution,
so as soon as we can, we spawn off a new thread to do the real work and
return.</p>
          

          
          <div class="method-source-code" id="babel_run_job-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">babel_run_job</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">jobs</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">jobs</span> = [<span class="ruby-identifier">jobs</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">run_or_delegate_tasks</span>(<span class="ruby-identifier">jobs</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;OK&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- babel_run_job-source -->
          
        </div>

        

        
      </div><!-- babel_run_job-method -->

    
      <div id="method-i-can_run_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">can_run_job</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="can_run_job-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 452</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">can_run_job</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-comment"># no input / output for appscale jobs</span>
  <span class="ruby-keyword">return</span> <span class="ruby-value">:ok</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&quot;appscale&quot;</span>

  <span class="ruby-identifier">storage</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@storage&quot;</span>]

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-constant">ALLOWED_STORAGE_TYPES</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">storage</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;error: bad storage type - supported types are #{ALLOWED_STORAGE_TYPES.join(', ')}&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">storage</span>, <span class="ruby-identifier">job_data</span>)

  <span class="ruby-identifier">input_location</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@input&quot;</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">input_location</span> <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-constant">NO_INPUT_NEEDED</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@type'</span>])
    <span class="ruby-identifier">input_exists</span> = <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">does_file_exist?</span>(<span class="ruby-identifier">input_location</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;input specified - did #{input_location} exist? #{input_exists}&quot;</span>)
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">input_exists</span>
      <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: input specified but did not exist&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;input not specified - moving on&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">output_location</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@output&quot;</span>]
  <span class="ruby-identifier">output_exists</span> = <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">does_file_exist?</span>(<span class="ruby-identifier">output_location</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;output specified - did #{output_location} exist? #{output_exists}&quot;</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">output_exists</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: output already exists&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;job type is [#{job_data[&quot;@type&quot;]}]&quot;</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-constant">NO_NODES_NEEDED</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>])
    <span class="ruby-keyword">return</span> <span class="ruby-value">:ok</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
      <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: failed to specify nodes_to_use, a required parameter&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">is_cloud?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">is_hybrid_cloud?</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;not in cloud&quot;</span>)
    <span class="ruby-comment"># make sure we have enough open nodes</span>
    <span class="ruby-comment"># a bit race-y, see the TODO on set for more info</span>

    <span class="ruby-comment"># In non-hybrid clouds, if the user specifies that they want to run over</span>
    <span class="ruby-comment"># multiple clouds, then either all clouds must be using remote resources</span>
    <span class="ruby-comment"># (e.g., only URLs are specified), or the first cloud has an integer value</span>
    <span class="ruby-comment"># (which we interpret as our cloud) and the others are remote clouds</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Array</span>
      <span class="ruby-identifier">hash_job_data</span> = <span class="ruby-constant">Hash</span>[*<span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]]
      <span class="ruby-identifier">hash_job_data</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">cloud</span>, <span class="ruby-identifier">nodes_needed</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes_needed</span> <span class="ruby-operator">=~</span> <span class="ruby-constant">URL_REGEX</span>
          <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saw URL [#{nodes_needed}] for cloud [#{cloud}] - &quot;</span> <span class="ruby-operator">+</span>
            <span class="ruby-string">&quot;moving on to next cloud&quot;</span>)
          <span class="ruby-keyword">next</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">cloud</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;cloud1&quot;</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">nodes_needed</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Fixnum</span>
          <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saw [#{nodes_needed}] nodes needed for cloud &quot;</span> <span class="ruby-operator">+</span>
            <span class="ruby-node">&quot;[#{cloud}] - moving on to next cloud&quot;</span>)
          <span class="ruby-keyword">next</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saw cloud [#{cloud}] and nodes needed &quot;</span> <span class="ruby-operator">+</span> 
          <span class="ruby-node">&quot;[#{nodes_needed}], which was not acceptable in non-hybrid &quot;</span> <span class="ruby-operator">+</span> 
          <span class="ruby-string">&quot;cloud deployments&quot;</span>)

        <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: cannot specify hybrid deployment in non-hybrid cloud runs&quot;</span>
      }

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">hash_job_data</span>[<span class="ruby-string">&quot;cloud1&quot;</span>].<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Fixnum</span>
        <span class="ruby-identifier">num_of_vms_needed</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">hash_job_data</span>[<span class="ruby-string">&quot;cloud1&quot;</span>])
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">return</span> <span class="ruby-value">:ok</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Fixnum</span>
      <span class="ruby-identifier">num_of_vms_needed</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>])
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: nodes_to_use specified was not an Array or Fixnum&quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot; but was a #{job_data['@nodes_to_use'].class}&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">nodes_to_use</span> = []
    <span class="ruby-ivar">@nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">is_open?</span>
        <span class="ruby-identifier">nodes_to_use</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">node</span>
        <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes_to_use</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">num_of_vms_needed</span>
      <span class="ruby-keyword">end</span>
    } 

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes_to_use</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">num_of_vms_needed</span>   
      <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;error: not enough free nodes (requested = #{num_of_vms_needed}, available = #{nodes_to_use.length})&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-value">:ok</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- can_run_job-source -->
          
        </div>

        

        
      </div><!-- can_run_job-method -->

    
      <div id="method-i-can_run_jobs_in_parallel-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">can_run_jobs_in_parallel?</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="can_run_jobs_in_parallel-3F-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">can_run_jobs_in_parallel?</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job_data</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@type'</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&quot;babel&quot;</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;job data #{job_data.inspect} is not a babel &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-string">&quot;job - not running in parallel&quot;</span>)
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">end</span>
  }
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- can_run_jobs_in_parallel-3F-source -->
          
        </div>

        

        
      </div><!-- can_run_jobs_in_parallel-3F-method -->

    
      <div id="method-i-cicero_run_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">cicero_run_job</span><span
            class="method-args">(nodes, jobs, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="cicero_run_job-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/cicero_helper.rb, line 40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cicero_run_job</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">jobs</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">Array</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;nodes must be an Array&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">job_data</span> = <span class="ruby-identifier">jobs</span>[<span class="ruby-value">0</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;job data must be a Hash&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;cicero - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">run_via_cicero</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;OK&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- cicero_run_job-source -->
          
        </div>

        

        
      </div><!-- cicero_run_job-method -->

    
      <div id="method-i-cleanup_code" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">cleanup_code</span><span
            class="method-args">(code)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="cleanup_code-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1088</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cleanup_code</span>(<span class="ruby-identifier">code</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">code</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;no code to remove&quot;</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">dirs</span> = <span class="ruby-identifier">code</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">%r\//</span>)
    <span class="ruby-identifier">code_dir</span> = <span class="ruby-identifier">dirs</span>[<span class="ruby-value">0</span>, <span class="ruby-identifier">dirs</span>.<span class="ruby-identifier">length</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>].<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;/&quot;</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">code_dir</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;/tmp&quot;</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;can't remove code located at #{code_dir}&quot;</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;code is located at #{code_dir}&quot;</span>)
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-node">&quot;rm -rf #{code_dir}&quot;</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- cleanup_code-source -->
          
        </div>

        

        
      </div><!-- cleanup_code-method -->

    
      <div id="method-i-compile_code" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">compile_code</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="compile_code-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 420</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compile_code</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-identifier">message</span> = <span class="ruby-identifier">validate_environment</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">message</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">message</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;compiling code&quot;</span>)

  <span class="ruby-identifier">main_file</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@main&quot;</span>]
  <span class="ruby-identifier">input_loc</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@code&quot;</span>]
  <span class="ruby-identifier">target</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@target&quot;</span>]

  <span class="ruby-identifier">compiled_dir</span> = <span class="ruby-node">&quot;/tmp/compiled-#{HelperFunctions.get_random_alphanumeric}&quot;</span>

  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">makefile</span> = <span class="ruby-identifier">input_loc</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;/Makefile&quot;</span>
    <span class="ruby-identifier">makefile2</span> = <span class="ruby-identifier">input_loc</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;/makefile&quot;</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">makefile</span>) <span class="ruby-keyword">or</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">makefile2</span>))
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">generate_makefile</span>(<span class="ruby-identifier">main_file</span>, <span class="ruby-identifier">input_loc</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">compile_cmd</span> = <span class="ruby-node">&quot;cd #{input_loc}; make #{target} 2&gt;compile_err 1&gt;compile_out&quot;</span>

    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;compiling code by running [#{compile_cmd}]&quot;</span>)

    <span class="ruby-identifier">result</span> = <span class="ruby-node">%x#{compile_cmd}`</span>
    <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-node">&quot;cp -r #{input_loc} #{compiled_dir}&quot;</span>)

  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">compiled_dir</span>  
<span class="ruby-keyword">end</span></pre>
          </div><!-- compile_code-source -->
          
        </div>

        

        
      </div><!-- compile_code-method -->

    
      <div id="method-i-copy_from_shadow" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">copy_from_shadow</span><span
            class="method-args">(location_on_shadow)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="copy_from_shadow-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy_from_shadow</span>(<span class="ruby-identifier">location_on_shadow</span>)
  <span class="ruby-identifier">shadow</span> = <span class="ruby-identifier">get_node_with_role</span>(<span class="ruby-string">&quot;shadow&quot;</span>)
  <span class="ruby-identifier">shadow_ip</span> = <span class="ruby-identifier">shadow</span>.<span class="ruby-identifier">private_ip</span>
  <span class="ruby-identifier">shadow_key</span> = <span class="ruby-identifier">shadow</span>.<span class="ruby-identifier">ssh_key</span>

  <span class="ruby-identifier">copy_from_shadow</span> = <span class="ruby-node">&quot;scp -r -i #{my_node.ssh_key} #{location_on_shadow} root@#{my_node.public_ip}:#{location_on_shadow}&quot;</span>
  <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">run_remote_command</span>(<span class="ruby-identifier">shadow_ip</span>, <span class="ruby-identifier">copy_from_shadow</span>, <span class="ruby-identifier">shadow_key</span>, <span class="ruby-constant">NO_OUTPUT</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- copy_from_shadow-source -->
          
        </div>

        

        
      </div><!-- copy_from_shadow-method -->

    
      <div id="method-i-dispatch_jobs" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dispatch_jobs</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="dispatch_jobs-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dispatch_jobs</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">can_run_jobs_in_parallel?</span>(<span class="ruby-identifier">jobs</span>)
    <span class="ruby-identifier">run_jobs_in_parallel</span>(<span class="ruby-identifier">jobs</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-constant">RUN_JOBS_IN_PARALLEL</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">run_jobs_in_serial</span>(<span class="ruby-identifier">jobs</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-constant">RUN_JOBS_IN_SERIAL</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- dispatch_jobs-source -->
          
        </div>

        

        
      </div><!-- dispatch_jobs-method -->

    
      <div id="method-i-does_file_exist" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">does_file_exist</span><span
            class="method-args">(file, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="does_file_exist-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 340</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">does_file_exist</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">does_file_exist?</span>(<span class="ruby-identifier">file</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- does_file_exist-source -->
          
        </div>

        

        
      </div><!-- does_file_exist-method -->

    
      <div id="method-i-execute_multiple_tasks" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">execute_multiple_tasks</span><span
            class="method-args">(tasks)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method spawns a thread for each task given to execute them in
parallel. It then waits for all tasks to complete before returning.</p>
          

          
          <div class="method-source-code" id="execute_multiple_tasks-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 730</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">execute_multiple_tasks</span>(<span class="ruby-identifier">tasks</span>)
  <span class="ruby-identifier">threads</span> = []
  <span class="ruby-identifier">tasks</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">task</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">threads</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
      <span class="ruby-identifier">run_task</span>(<span class="ruby-identifier">task</span>)
    }
  }

  <span class="ruby-identifier">threads</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">t</span>.<span class="ruby-identifier">join</span> }
<span class="ruby-keyword">end</span></pre>
          </div><!-- execute_multiple_tasks-source -->
          
        </div>

        

        
      </div><!-- execute_multiple_tasks-method -->

    
      <div id="method-i-find_neighbors" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">find_neighbors</span><span
            class="method-args">(val, search_space)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="find_neighbors-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 960</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">find_neighbors</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">search_space</span>)
  <span class="ruby-identifier">abort</span>(<span class="ruby-string">&quot;no empty arrays&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">search_space</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">search_space</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">length</span> = <span class="ruby-identifier">search_space</span>.<span class="ruby-identifier">length</span>
  <span class="ruby-identifier">search_space</span>.<span class="ruby-identifier">each_with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># set left</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">left</span> = <span class="ruby-identifier">val</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">left</span> = <span class="ruby-identifier">search_space</span>[<span class="ruby-identifier">index</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>]
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># set right</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">right</span> = <span class="ruby-identifier">search_space</span>[<span class="ruby-identifier">index</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">right</span> = <span class="ruby-identifier">val</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">item</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">val</span>
  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- find_neighbors-source -->
          
        </div>

        

        
      </div><!-- find_neighbors-method -->

    
      <div id="method-i-find_open_nodes" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">find_open_nodes</span><span
            class="method-args">(cloud, nodes_needed, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="find_open_nodes-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 777</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">find_open_nodes</span>(<span class="ruby-identifier">cloud</span>, <span class="ruby-identifier">nodes_needed</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-comment"># TODO: assigning nodes -&gt; nodes_to_use should be atomic?</span>
  <span class="ruby-comment"># or should going through this list be atomic?</span>

  <span class="ruby-identifier">nodes_to_use</span> = <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">find_open_nodes_in_cloud</span>(<span class="ruby-identifier">nodes_needed</span>, <span class="ruby-identifier">cloud</span>)

  <span class="ruby-ivar">@nodes_in_use</span> = <span class="ruby-identifier">nodes_to_use</span>

  <span class="ruby-identifier">nodes_available</span> = <span class="ruby-identifier">nodes_to_use</span>.<span class="ruby-identifier">length</span>
  <span class="ruby-identifier">new_nodes_needed</span> = <span class="ruby-identifier">nodes_needed</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">nodes_available</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;need #{nodes_needed} total, currently have #{nodes_available} to spare&quot;</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_cloud?</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_nodes_needed</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;spawning up #{new_nodes_needed} for neptune job in cloud 1&quot;</span>)
      <span class="ruby-identifier">acquire_nodes_for_cloud</span>(<span class="ruby-identifier">cloud_num</span>, <span class="ruby-identifier">new_nodes_needed</span>, <span class="ruby-identifier">job_data</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_nodes_needed</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;non-cloud deployment and the neptune user has asked for too many nodes&quot;</span>)
      <span class="ruby-comment"># TODO: find a way to reject the job here</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">nodes_to_use</span> = []
  <span class="ruby-ivar">@nodes_in_use</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes_to_use</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">nodes_needed</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">is_open?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">cloud</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">cloud</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;will use node [#{node}] for computation&quot;</span>)
      <span class="ruby-identifier">nodes_to_use</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">node</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">nodes_to_use</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- find_open_nodes-source -->
          
        </div>

        

        
      </div><!-- find_open_nodes-method -->

    
      <div id="method-i-get_acl" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_acl</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_acl-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 370</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_acl</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-identifier">message</span> = <span class="ruby-identifier">validate_environment</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">message</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">message</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;requesting acl&quot;</span>)

  <span class="ruby-identifier">type</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>]

  <span class="ruby-identifier">output_location</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@output&quot;</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">output_location</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: output not specified&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">does_file_exist?</span>(<span class="ruby-identifier">output_location</span>)
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">get_acl</span>(<span class="ruby-identifier">output_location</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_acl-source -->
          
        </div>

        

        
      </div><!-- get_acl-method -->

    
      <div id="method-i-get_engines_for_creds" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_engines_for_creds</span><span
            class="method-args">(job_data, credentials, engines_to_add)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Checks the credentials that the user has given us (job_data) to see if they
match up to the credentials needed for the given engine. If so, we return
the list of engines that can be safely added.</p>
          

          
          <div class="method-source-code" id="get_engines_for_creds-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_engines_for_creds</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">credentials</span>, <span class="ruby-identifier">engines_to_add</span>)

  <span class="ruby-identifier">credentials</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">cred</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">job_data</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">cred</span>)
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;credentials did not have #{cred}, so not &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot;#{engines_to_add.join(', ')}&quot;</span>)
      <span class="ruby-keyword">return</span> []
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;adding engines #{engines_to_add.join(', ')}&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">engines_to_add</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_engines_for_creds-source -->
          
        </div>

        

        
      </div><!-- get_engines_for_creds-method -->

    
      <div id="method-i-get_job_data" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_data</span><span
            class="method-args">(job_name, time)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_job_data-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 987</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_data</span>(<span class="ruby-identifier">job_name</span>, <span class="ruby-identifier">time</span>)
  <span class="ruby-identifier">relevant_jobs</span> = <span class="ruby-ivar">@jobs</span>[<span class="ruby-identifier">job_name</span>]
  <span class="ruby-identifier">relevant_jobs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">job</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">job</span>.<span class="ruby-identifier">total_time</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">time</span>
  }

  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_data-source -->
          
        </div>

        

        
      </div><!-- get_job_data-method -->

    
      <div id="method-i-get_job_name" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_job_name</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_job_name-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 844</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_job_name</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">job_name</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>]

  [<span class="ruby-string">&quot;@code&quot;</span>, <span class="ruby-string">&quot;@main&quot;</span>, <span class="ruby-string">&quot;@map&quot;</span>, <span class="ruby-string">&quot;@reduce&quot;</span>, <span class="ruby-string">&quot;@simulations&quot;</span>, <span class="ruby-string">&quot;@add_component&quot;</span>].<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-identifier">item</span>]
      <span class="ruby-identifier">job_name</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot; - &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-node">&quot;#{job_data[item]}&quot;</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">job_name</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_job_name-source -->
          
        </div>

        

        
      </div><!-- get_job_name-method -->

    
      <div id="method-i-get_length_of_all_queues" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_length_of_all_queues</span><span
            class="method-args">(queues)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_length_of_all_queues-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 616</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_length_of_all_queues</span>(<span class="ruby-identifier">queues</span>)
  <span class="ruby-comment"># something to consider: do leased tasks count in the size?</span>
  <span class="ruby-identifier">length</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">queues</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">q</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">length</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">q</span>.<span class="ruby-identifier">size</span>
  }
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">length</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_length_of_all_queues-source -->
          
        </div>

        

        
      </div><!-- get_length_of_all_queues-method -->

    
      <div id="method-i-get_lock_file_path" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_lock_file_path</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_lock_file_path-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 708</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_lock_file_path</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">job</span> = <span class="ruby-identifier">job_data</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">job_data</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Array</span>
    <span class="ruby-identifier">job</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-value">0</span>]
  <span class="ruby-keyword">end</span>
    
  <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;/tmp/#{job['@type']}-#{job['@job_id']}-started&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_lock_file_path-source -->
          
        </div>

        

        
      </div><!-- get_lock_file_path-method -->

    
      <div id="method-i-get_n_items_of_work" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_n_items_of_work</span><span
            class="method-args">(n, queues)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_n_items_of_work-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 626</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_n_items_of_work</span>(<span class="ruby-identifier">n</span>, <span class="ruby-identifier">queues</span>)
  <span class="ruby-identifier">items</span> = []

  <span class="ruby-identifier">queues</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">q</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">loop</span> {
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;popping an item of work off of queue #{q}&quot;</span>)
      <span class="ruby-identifier">start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
      <span class="ruby-identifier">new_item</span> = <span class="ruby-identifier">q</span>.<span class="ruby-identifier">pop</span>
      <span class="ruby-identifier">end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_item</span>.<span class="ruby-identifier">nil?</span>
        <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{q} is empty - moving on to next queue&quot;</span>)
        <span class="ruby-keyword">break</span>  <span class="ruby-comment"># the queue is empty</span>
      <span class="ruby-keyword">end</span>
  
      <span class="ruby-comment"># add how long it took to grab the item from the queue to our metadata</span>
      <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">new_item</span>[<span class="ruby-string">&quot;@metadata_info&quot;</span>]
        <span class="ruby-identifier">new_item</span> = {}
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">queue_pop_time</span> = <span class="ruby-identifier">end_time</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">start_time</span>
      <span class="ruby-identifier">new_item</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'queue_pop_time'</span>] = <span class="ruby-identifier">queue_pop_time</span>

      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;adding [#{new_item}][#{new_item.class}] to items&quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot; - took #{queue_pop_time} seconds to pop it off the queue&quot;</span>)
      <span class="ruby-identifier">items</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_item</span>

      <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">n</span>
    }

    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">n</span>
  }

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;returning [#{items.join(', ')}] items of work&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">items</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_n_items_of_work-source -->
          
        </div>

        

        
      </div><!-- get_n_items_of_work-method -->

    
      <div id="method-i-get_node_roles" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_node_roles</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_node_roles-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 583</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_node_roles</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;getting node roles&quot;</span>)
  <span class="ruby-identifier">job_type</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>]

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_type</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;appscale&quot;</span>
    <span class="ruby-identifier">component_to_add</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@add_component&quot;</span>]
    <span class="ruby-identifier">master_role</span> = <span class="ruby-identifier">component_to_add</span>
    <span class="ruby-identifier">slave_roles</span> = <span class="ruby-identifier">component_to_add</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">job_type</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;mapreduce&quot;</span>
    <span class="ruby-identifier">master_role</span> = <span class="ruby-string">&quot;db_slave:mapreduce_master&quot;</span>
    <span class="ruby-identifier">slave_roles</span> = <span class="ruby-string">&quot;db_slave:mapreduce_slave&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">master_role</span> = <span class="ruby-node">&quot;#{job_type}_master&quot;</span>
    <span class="ruby-identifier">slave_roles</span> = <span class="ruby-node">&quot;#{job_type}_slave&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;master role is [#{master_role}], slave roles are &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;[#{slave_roles}]&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">master_role</span>, <span class="ruby-identifier">slave_roles</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_node_roles-source -->
          
        </div>

        

        
      </div><!-- get_node_roles-method -->

    
      <div id="method-i-get_node_with_role" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_node_with_role</span><span
            class="method-args">(role)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_node_with_role-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_node_with_role</span>(<span class="ruby-identifier">role</span>)
  <span class="ruby-identifier">ip_info</span> = <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">get_ip_info</span>()
  <span class="ruby-identifier">all_ips</span> = <span class="ruby-identifier">ip_info</span>[<span class="ruby-string">'ips'</span>]
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;All IPs are #{all_ips}&quot;</span>)

  <span class="ruby-identifier">all_ips</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ip</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">job_data</span> = <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">get_job_data_for_ip</span>(<span class="ruby-identifier">ip</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Job data for #{ip} is #{job_data}&quot;</span>)
    <span class="ruby-identifier">node</span> = <span class="ruby-constant">DjinnJobData</span>.<span class="ruby-identifier">deserialize</span>(<span class="ruby-identifier">job_data</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">role</span>)
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{ip} does have role #{role}, returning it&quot;</span>)
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{ip} does not have role #{role}, moving on&quot;</span>)
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Exception</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;No nodes have role #{role}&quot;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_node_with_role-source -->
          
        </div>

        

        
      </div><!-- get_node_with_role-method -->

    
      <div id="method-i-get_output" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_output</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_output-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 346</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_output</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-identifier">message</span> = <span class="ruby-identifier">validate_environment</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">message</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">message</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;requesting output&quot;</span>)

  <span class="ruby-identifier">type</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>]

  <span class="ruby-identifier">output_location</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@output&quot;</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">output_location</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: output not specified&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">does_file_exist?</span>(<span class="ruby-identifier">output_location</span>)
      <span class="ruby-comment"># TODO: maybe write to file or have</span>
      <span class="ruby-comment"># special flag for this?</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">get_output_and_return_contents</span>(<span class="ruby-identifier">output_location</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_output-source -->
          
        </div>

        

        
      </div><!-- get_output-method -->

    
      <div id="method-i-get_queues_from_shadow" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_queues_from_shadow</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_queues_from_shadow-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 589</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_queues_from_shadow</span>()
  <span class="ruby-identifier">secret</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>()
  <span class="ruby-identifier">acc</span> = <span class="ruby-constant">AppControllerClient</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">get_shadow</span>.<span class="ruby-identifier">public_ip</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-identifier">json_queue_and_cred_info</span> = <span class="ruby-identifier">acc</span>.<span class="ruby-identifier">get_queues_in_use</span>()
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;raw json received is '#{json_queue_and_cred_info}'&quot;</span>)
  <span class="ruby-identifier">queue_and_cred_info</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">load</span>(<span class="ruby-identifier">json_queue_and_cred_info</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;json formatted data is [#{queue_and_cred_info}]&quot;</span>)

  <span class="ruby-identifier">queues</span> = []
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">queue_and_cred_info</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;queues from shadow are nil&quot;</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">queues</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">queue_and_cred_info</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">info</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;this queue's info is #{info.inspect}&quot;</span>)
    <span class="ruby-identifier">engine</span> = <span class="ruby-identifier">info</span>.<span class="ruby-identifier">keys</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">credentials</span> = <span class="ruby-identifier">info</span>.<span class="ruby-identifier">values</span>[<span class="ruby-value">0</span>]
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;engine is [#{engine}], credentials are [#{credentials.inspect}]&quot;</span>)
    <span class="ruby-identifier">queues</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">QueueFactory</span>.<span class="ruby-identifier">get_queue</span>(<span class="ruby-identifier">engine</span>, <span class="ruby-identifier">credentials</span>)
  }

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;queues from shadow are [#{queues.join(', ')}]&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">queues</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_queues_from_shadow-source -->
          
        </div>

        

        
      </div><!-- get_queues_from_shadow-method -->

    
      <div id="method-i-get_queues_in_use" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_queues_in_use</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can be stored in multiple queues concurrently, so this method
provides workers (babel_slaves) with the way to learn what queues are
currently in use and the credentials needed to access them.</p>
          

          
          <div class="method-source-code" id="get_queues_in_use-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 309</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_queues_in_use</span>(<span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;@queues_to_read is #{@queues_to_read.join(', ')}, class #{@queues_to_read.class}&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">dump</span>(<span class="ruby-ivar">@queues_to_read</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_queues_in_use-source -->
          
        </div>

        

        
      </div><!-- get_queues_in_use-method -->

    
      <div id="method-i-get_seed_vals" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_seed_vals</span><span
            class="method-args">(num_vals)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="get_seed_vals-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1026</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_seed_vals</span>(<span class="ruby-identifier">num_vals</span>)
  <span class="ruby-identifier">random_numbers</span> = []
  <span class="ruby-identifier">num_vals</span>.<span class="ruby-identifier">times</span> {
    <span class="ruby-identifier">loop</span> {
      <span class="ruby-identifier">possible_rand</span> = <span class="ruby-identifier">rand</span>(<span class="ruby-value">10000</span>)
      <span class="ruby-keyword">unless</span> <span class="ruby-identifier">random_numbers</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">possible_rand</span>)
        <span class="ruby-identifier">random_numbers</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">possible_rand</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    }
  }

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">random_numbers</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_seed_vals-source -->
          
        </div>

        

        
      </div><!-- get_seed_vals-method -->

    
      <div id="method-i-get_supported_babel_engines" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">get_supported_babel_engines</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can execute over a number of different engines (a queue and an
executor). From the credentials the user has given us (job_data), determine
which engines can be used.</p>
          

          
          <div class="method-source-code" id="get_supported_babel_engines-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_supported_babel_engines</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;checking supported engines for job data &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;#{job_data.inspect}&quot;</span>)

  <span class="ruby-comment"># all jobs can use the internal engines</span>
  <span class="ruby-identifier">engines</span> = <span class="ruby-constant">INTERNAL_ENGINES</span>

  <span class="ruby-comment"># but not necessarily the others, so check them one by one</span>
  <span class="ruby-identifier">engines</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">get_engines_for_creds</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-constant">AMAZON_CREDENTIALS</span>, 
    <span class="ruby-constant">AMAZON_ENGINES</span>)
  <span class="ruby-identifier">engines</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">get_engines_for_creds</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-constant">AZURE_CREDENTIALS</span>, 
    <span class="ruby-constant">AZURE_ENGINES</span>)
  <span class="ruby-identifier">engines</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">get_engines_for_creds</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-constant">GOOGLE_CREDENTIALS</span>, 
    <span class="ruby-constant">GOOGLE_ENGINES</span>)
 
  <span class="ruby-comment"># since we're appending arrays to arrays but want it to be a 1D array</span>
  <span class="ruby-identifier">engines</span>.<span class="ruby-identifier">flatten!</span>.<span class="ruby-identifier">uniq!</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;supported engines for job data #{job_data.inspect} &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;are [#{engines.join(', ')}]&quot;</span>)

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">engines</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- get_supported_babel_engines-source -->
          
        </div>

        

        
      </div><!-- get_supported_babel_engines-method -->

    
      <div id="method-i-has_all_required_params-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">has_all_required_params?</span><span
            class="method-args">(job_data, required_params)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Verifies that the given job_data has all of the parameters specified by
required_params.</p>
          

          
          <div class="method-source-code" id="has_all_required_params-3F-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1064</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">has_all_required_params?</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">required_params</span>)
  <span class="ruby-identifier">required_params</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">param</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-identifier">param</span>].<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- has_all_required_params-3F-source -->
          
        </div>

        

        
      </div><!-- has_all_required_params-3F-method -->

    
      <div id="method-i-initialize_zookeeper_connection" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">initialize_zookeeper_connection</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="initialize_zookeeper_connection-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize_zookeeper_connection</span>()
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-constant">ZK_LOCATIONS_FILE</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">Exception</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Couldn't find the ZooKeeper locations file&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">my_public_ip</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_my_public_ip</span>()
  <span class="ruby-identifier">zookeeper_data</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">read_json_file</span>(<span class="ruby-constant">ZK_LOCATIONS_FILE</span>)
  <span class="ruby-identifier">zk_ips</span> = <span class="ruby-identifier">zookeeper_data</span>[<span class="ruby-string">'locations'</span>]
  <span class="ruby-identifier">zk_ips</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ip</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Initializing ZooKeeper client to ZK at #{ip}&quot;</span>)
      <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">init_to_ip</span>(<span class="ruby-identifier">my_public_ip</span>, <span class="ruby-identifier">ip</span>)
    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Saw exception of class #{e.class} from #{ip}, &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-string">&quot;trying next ZooKeeper node&quot;</span>)
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Initialized ZooKeeper successfully from #{ip}&quot;</span>)
    <span class="ruby-keyword">return</span>
  }

  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Exception</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Couldn't initialize a ZooKeeper connnection to &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;any of these IPs: #{zk_ips}&quot;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- initialize_zookeeper_connection-source -->
          
        </div>

        

        
      </div><!-- initialize_zookeeper_connection-method -->

    
      <div id="method-i-is_cloud-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_cloud?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="is_cloud-3F-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_cloud?</span>()
  <span class="ruby-identifier">cloud_info</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_cloud_info</span>()
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">cloud_info</span>[<span class="ruby-string">'is_cloud?'</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_cloud-3F-source -->
          
        </div>

        

        
      </div><!-- is_cloud-3F-method -->

    
      <div id="method-i-is_hybrid_cloud-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_hybrid_cloud?</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="is_hybrid_cloud-3F-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_hybrid_cloud?</span>()
  <span class="ruby-identifier">cloud_info</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_cloud_info</span>()
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">cloud_info</span>[<span class="ruby-string">'is_hybrid_cloud?'</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_hybrid_cloud-3F-source -->
          
        </div>

        

        
      </div><!-- is_hybrid_cloud-3F-method -->

    
      <div id="method-i-is_job_running" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_job_running</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="is_job_running-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_job_running</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">lock_file_exists?</span>(<span class="ruby-identifier">job_data</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- is_job_running-source -->
          
        </div>

        

        
      </div><!-- is_job_running-method -->

    
      <div id="method-i-lock_file_exists-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">lock_file_exists?</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="lock_file_exists-3F-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 686</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lock_file_exists?</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">get_lock_file_path</span>(<span class="ruby-identifier">job_data</span>))
<span class="ruby-keyword">end</span></pre>
          </div><!-- lock_file_exists-3F-source -->
          
        </div>

        

        
      </div><!-- lock_file_exists-3F-method -->

    
      <div id="method-i-manage_virtual_machines" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">manage_virtual_machines</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>TODO(cgb): fix this broken code, moved from the AppController</p>
          

          
          <div class="method-source-code" id="manage_virtual_machines-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">manage_virtual_machines</span>()
  <span class="ruby-ivar">@nodes_in_use</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-node">&quot;Currently examining node [#{node}]&quot;</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">should_extend?</span>
      <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-node">&quot;Extending time for node [#{node}]&quot;</span>)
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">extend_time</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">should_destroy?</span>
      <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-node">&quot;Time is up for node [#{node}] - destroying it&quot;</span>)
      <span class="ruby-ivar">@nodes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">node</span>)
      <span class="ruby-ivar">@nodes_in_use</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">node</span>)
      <span class="ruby-identifier">infrastructure</span> = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">&quot;infrastructure&quot;</span>]
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">terminate_vms</span>([<span class="ruby-identifier">node</span>], <span class="ruby-identifier">infrastructure</span>)
      <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_f</span>(<span class="ruby-node">&quot;/etc/appscale/status-#{node.private_ip}.json&quot;</span>)
    <span class="ruby-keyword">end</span>
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- manage_virtual_machines-source -->
          
        </div>

        

        
      </div><!-- manage_virtual_machines-method -->

    
      <div id="method-i-mapreduce_run_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mapreduce_run_job</span><span
            class="method-args">(nodes, jobs, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="mapreduce_run_job-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/mapreduce_helper.rb, line 41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">mapreduce_run_job</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">jobs</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;MapReduce - run job&quot;</span>)

  <span class="ruby-identifier">job_data</span> = <span class="ruby-identifier">jobs</span>[<span class="ruby-value">0</span>]

  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">nodes</span> = <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span> <span class="ruby-constant">DjinnJobData</span>.<span class="ruby-identifier">deserialize</span>(<span class="ruby-identifier">node</span>) }
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Converted node data is #{nodes}&quot;</span>)

    <span class="ruby-identifier">storage</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@storage&quot;</span>]
    <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">storage</span>, <span class="ruby-identifier">job_data</span>)

    <span class="ruby-identifier">mapreducejar</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@mapreducejar&quot;</span>]
    <span class="ruby-identifier">main</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@main&quot;</span>]

    <span class="ruby-identifier">map</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@map&quot;</span>]
    <span class="ruby-identifier">reduce</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@reduce&quot;</span>]

    <span class="ruby-identifier">input</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@input&quot;</span>]
    <span class="ruby-identifier">output</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@output&quot;</span>]

    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;MR: Copying mapper and reducer to all boxes&quot;</span>)
    <span class="ruby-comment"># TODO: get files from shadow first if in cloud</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">mapreducejar</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;need to get mr jar located at #{mapreducejar}&quot;</span>)
      <span class="ruby-identifier">mr_file</span> = <span class="ruby-identifier">mapreducejar</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">'/'</span>)[<span class="ruby-value">-1</span>]
      <span class="ruby-identifier">my_mrjar</span> = <span class="ruby-node">&quot;/tmp/#{mr_file}&quot;</span>
      <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">get_output_and_save_to_fs</span>(<span class="ruby-identifier">mapreducejar</span>, <span class="ruby-identifier">my_mrjar</span>)

      <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">scp_file</span>(<span class="ruby-identifier">my_mrjar</span>, <span class="ruby-identifier">my_mrjar</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">private_ip</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">ssh_key</span>)
      }

      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Copying MapReduce jar to db_master node&quot;</span>)
      <span class="ruby-identifier">db_master</span> = <span class="ruby-identifier">get_node_with_role</span>(<span class="ruby-string">&quot;db_master&quot;</span>)
      <span class="ruby-identifier">ip</span> = <span class="ruby-identifier">db_master</span>.<span class="ruby-identifier">private_ip</span>
      <span class="ruby-identifier">ssh_key</span> = <span class="ruby-identifier">db_master</span>.<span class="ruby-identifier">ssh_key</span>
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">scp_file</span>(<span class="ruby-identifier">my_mrjar</span>, <span class="ruby-identifier">my_mrjar</span>, <span class="ruby-identifier">ip</span>, <span class="ruby-identifier">ssh_key</span>)

      <span class="ruby-identifier">run_mr_command</span> = <span class="ruby-node">&quot;#{HADOOP_EXECUTABLE} jar #{my_mrjar} #{main} &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot;#{input} #{output}&quot;</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Need to get Map code located at #{map}, and &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot;Reduce code located at #{reduce}&quot;</span>)

      <span class="ruby-identifier">map_file</span> = <span class="ruby-identifier">map</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">'/'</span>)[<span class="ruby-value">-1</span>]
      <span class="ruby-identifier">red_file</span> = <span class="ruby-identifier">reduce</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">'/'</span>)[<span class="ruby-value">-1</span>]

      <span class="ruby-identifier">my_map</span> = <span class="ruby-node">&quot;/tmp/#{map_file}&quot;</span>
      <span class="ruby-identifier">my_red</span> = <span class="ruby-node">&quot;/tmp/#{red_file}&quot;</span>

      <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_rf</span>(<span class="ruby-identifier">my_map</span>)
      <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_rf</span>(<span class="ruby-identifier">my_red</span>)

      <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">get_single_file_and_save_to_fs</span>(<span class="ruby-identifier">map</span>, <span class="ruby-identifier">my_map</span>)
      <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">get_single_file_and_save_to_fs</span>(<span class="ruby-identifier">reduce</span>, <span class="ruby-identifier">my_red</span>)

      <span class="ruby-comment"># since the db master is the initiator of the mapreduce job, it needs</span>
      <span class="ruby-comment"># to have both the mapper and reducer files handy</span>

      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Copying Mapper and Reducer to db_master node, &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-string">&quot;since it runs the MapReduce job&quot;</span>)

      <span class="ruby-identifier">db_master</span> = <span class="ruby-identifier">get_node_with_role</span>(<span class="ruby-string">&quot;db_master&quot;</span>)
      <span class="ruby-identifier">ip</span> = <span class="ruby-identifier">db_master</span>.<span class="ruby-identifier">private_ip</span>
      <span class="ruby-identifier">ssh_key</span> = <span class="ruby-identifier">db_master</span>.<span class="ruby-identifier">ssh_key</span>
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">scp_file</span>(<span class="ruby-identifier">my_map</span>, <span class="ruby-identifier">my_map</span>, <span class="ruby-identifier">ip</span>, <span class="ruby-identifier">ssh_key</span>)
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">scp_file</span>(<span class="ruby-identifier">my_red</span>, <span class="ruby-identifier">my_red</span>, <span class="ruby-identifier">ip</span>, <span class="ruby-identifier">ssh_key</span>)

      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Copying Mapper and Reducer to all nodes used &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-string">&quot;for this MapReduce job&quot;</span>)

      <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
        <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">scp_file</span>(<span class="ruby-identifier">my_map</span>, <span class="ruby-identifier">my_map</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">private_ip</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">ssh_key</span>)
        <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">scp_file</span>(<span class="ruby-identifier">my_red</span>, <span class="ruby-identifier">my_red</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">private_ip</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">ssh_key</span>)
      }


      <span class="ruby-identifier">map_cmd</span> = <span class="ruby-string">&quot;\&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">get_language</span>(<span class="ruby-identifier">my_map</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">my_map</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot;&quot;</span>
      <span class="ruby-identifier">reduce_cmd</span> = <span class="ruby-string">&quot;\&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">get_language</span>(<span class="ruby-identifier">my_red</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">my_red</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot;&quot;</span>

      <span class="ruby-identifier">run_mr_command</span> = <span class="ruby-node">&quot;#{HADOOP_EXECUTABLE} jar #{HADOOP_STREAMING_JAR} &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot;-input #{input} -output #{output} -mapper #{map_cmd} &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot;-reducer #{reduce_cmd}&quot;</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Running MapReduce job, with command &quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-node">&quot;[#{run_mr_command}]&quot;</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;waiting for input file #{input} to exist in HDFS&quot;</span>)
    <span class="ruby-identifier">wait_for_hdfs_file</span>(<span class="ruby-identifier">input</span>)

    <span class="ruby-comment"># run mr job</span>
    <span class="ruby-identifier">start</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>

    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;MR: Running job&quot;</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;MR: Command is #{run_mr_command}&quot;</span>)
    <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-identifier">run_mr_command</span>)

    <span class="ruby-identifier">wait_for_hdfs_file</span>(<span class="ruby-identifier">output</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;MR: Done running job!&quot;</span>)

    <span class="ruby-identifier">fin</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;TIMING: Total time is #{fin - start} seconds&quot;</span>)

    <span class="ruby-comment"># TODO: check if no part-* files exist - if so, there's an error</span>
    <span class="ruby-comment"># that we should funnel to the user somehow</span>

    <span class="ruby-identifier">output_cmd</span> = <span class="ruby-node">&quot;#{HADOOP_EXECUTABLE} fs -cat #{output}/part-*&quot;</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;MR: Retrieving job output with command #{output_cmd}&quot;</span>)
    <span class="ruby-identifier">output_str</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-identifier">output_cmd</span>)
    <span class="ruby-identifier">write_job_output_str</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">output_str</span>)

    <span class="ruby-identifier">remove_lock_file</span>(<span class="ruby-identifier">job_data</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;OK&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- mapreduce_run_job-source -->
          
        </div>

        

        
      </div><!-- mapreduce_run_job-method -->

    
      <div id="method-i-mpi_run_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">mpi_run_job</span><span
            class="method-args">(nodes, job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="mpi_run_job-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/mpi_helper.rb, line 20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">mpi_run_job</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
  <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-string">&quot;mpi - run&quot;</span>)

  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>] = {<span class="ruby-string">'received_job_at'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">to_i</span>}

    <span class="ruby-identifier">keyname</span> = <span class="ruby-ivar">@creds</span>[<span class="ruby-string">'keyname'</span>]
    <span class="ruby-identifier">nodes</span> = <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">convert_location_array_to_class</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">keyname</span>)

    <span class="ruby-constant">ENV</span>[<span class="ruby-string">'LD_LIBRARY_PATH'</span>] = <span class="ruby-string">&quot;/usr/lib&quot;</span>
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-node">&quot;library path = #{ENV['LD_LIBRARY_PATH']}&quot;</span>)

    <span class="ruby-identifier">start_nfs</span>(<span class="ruby-identifier">nodes</span>)

    <span class="ruby-identifier">sleep</span>(<span class="ruby-value">5</span>) <span class="ruby-comment"># CGB</span>

    <span class="ruby-identifier">shadow</span> = <span class="ruby-identifier">get_shadow</span>
    <span class="ruby-identifier">shadow_ip</span> = <span class="ruby-identifier">shadow</span>.<span class="ruby-identifier">private_ip</span>
    <span class="ruby-identifier">shadow_key</span> = <span class="ruby-identifier">shadow</span>.<span class="ruby-identifier">ssh_key</span>

    <span class="ruby-identifier">remote</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>]
    <span class="ruby-identifier">splitted_code</span> = <span class="ruby-identifier">remote</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">'/'</span>)
    <span class="ruby-identifier">remote_dir</span> = <span class="ruby-identifier">splitted_code</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">splitted_code</span>.<span class="ruby-identifier">length</span><span class="ruby-operator">-</span><span class="ruby-value">2</span>].<span class="ruby-identifier">join</span>(<span class="ruby-string">'/'</span>)
    <span class="ruby-identifier">filename_to_exec</span> = <span class="ruby-identifier">splitted_code</span>[<span class="ruby-value">2</span><span class="ruby-operator">..</span><span class="ruby-identifier">splitted_code</span>.<span class="ruby-identifier">length</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>].<span class="ruby-identifier">join</span>(<span class="ruby-string">'/'</span>)
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-node">&quot;remote dir is [#{remote_dir}], filename_to_exec is #{filename_to_exec}&quot;</span>)

    <span class="ruby-identifier">storage</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>]

    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">my_node</span>.<span class="ruby-identifier">is_shadow?</span>
      <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_run</span>(<span class="ruby-node">&quot;rm -fv /tmp/#{filename_to_exec}&quot;</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">working_dir</span> = <span class="ruby-node">&quot;/mirrornfs/#{HelperFunctions.get_random_alphanumeric()}&quot;</span>
    <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">mkdir_p</span>(<span class="ruby-identifier">working_dir</span>)
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">copy_code_and_inputs_to_dir</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">working_dir</span>)

    <span class="ruby-identifier">start_mpd</span>(<span class="ruby-identifier">nodes</span>)
    <span class="ruby-identifier">sleep</span>(<span class="ruby-value">5</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@procs_to_use&quot;</span>]
      <span class="ruby-identifier">num_of_procs</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@procs_to_use&quot;</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">num_of_procs</span> = <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">length</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Some job types (e.g., kdt) need to specify something a program to use</span>
    <span class="ruby-comment"># to run the user's code (e.g., Python), so let them do so via the</span>
    <span class="ruby-comment"># executable parameter.</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@executable&quot;</span>]
      <span class="ruby-identifier">executable</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@executable&quot;</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">executable</span> = <span class="ruby-string">&quot;&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># If the user specifies an argv to pass to the code to exec, be sure to</span>
    <span class="ruby-comment"># capture it and pass it along</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@argv&quot;</span>]
      <span class="ruby-identifier">argv</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@argv&quot;</span>]
      <span class="ruby-comment"># TODO(cgb): filter out colons and other things that malicious users could</span>
      <span class="ruby-comment"># use to hijack the system</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">argv</span> = <span class="ruby-string">&quot;&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">output_file</span> = <span class="ruby-node">&quot;/tmp/mpi-output-#{rand()}&quot;</span>
    <span class="ruby-identifier">error_file</span> = <span class="ruby-node">&quot;/tmp/mpi-error-#{rand()}&quot;</span>

    <span class="ruby-identifier">full_path_to_file</span> = <span class="ruby-node">&quot;#{working_dir}/#{filename_to_exec}&quot;</span>

    <span class="ruby-identifier">start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_run</span>(<span class="ruby-node">&quot;mpiexec -env X10_NTHREADS 1 -n #{num_of_procs} &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-node">&quot;#{executable} #{full_path_to_file} #{argv} 1&gt;#{output_file} 2&gt;#{error_file}&quot;</span>)
    <span class="ruby-identifier">end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
 
    <span class="ruby-identifier">total</span> = <span class="ruby-identifier">end_time</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">start_time</span>
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-string">&quot;MPI: Done running job!&quot;</span>)
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-node">&quot;TIMING: Took #{total} seconds&quot;</span>)

    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'start_time'</span>] = <span class="ruby-identifier">start_time</span>.<span class="ruby-identifier">to_i</span>
    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'end_time'</span>] = <span class="ruby-identifier">end_time</span>.<span class="ruby-identifier">to_i</span>
    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'total_execution_time'</span>] = <span class="ruby-identifier">total</span>

    <span class="ruby-identifier">stop_mpd</span>()

    <span class="ruby-identifier">stop_nfs</span>(<span class="ruby-identifier">nodes</span>)

    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">write_babel_outputs</span>(<span class="ruby-identifier">output_file</span>, <span class="ruby-identifier">error_file</span>, <span class="ruby-identifier">job_data</span>)

    <span class="ruby-comment"># clean up after ourselves - remove the user's code and any outputs</span>
    <span class="ruby-comment"># it may have produced</span>
    <span class="ruby-constant">Djinn</span>.<span class="ruby-identifier">log_debug</span>(<span class="ruby-node">&quot;Removing working dir #{working_dir}&quot;</span>)
    <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_rf</span>(<span class="ruby-identifier">working_dir</span>)
    <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_rf</span>(<span class="ruby-identifier">output_file</span>)
    <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">rm_rf</span>(<span class="ruby-identifier">error_file</span>)

    <span class="ruby-identifier">remove_lock_file</span>(<span class="ruby-identifier">job_data</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;OK&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- mpi_run_job-source -->
          
        </div>

        

        
      </div><!-- mpi_run_job-method -->

    
      <div id="method-i-my_node" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">my_node</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="my_node-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">my_node</span>
  <span class="ruby-identifier">my_ip</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_my_public_ip</span>()
  <span class="ruby-identifier">zk_job_data</span> = <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">get_job_data_for_ip</span>(<span class="ruby-identifier">my_ip</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;My node's job data is #{zk_job_data}&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">DjinnJobData</span>.<span class="ruby-identifier">deserialize</span>(<span class="ruby-identifier">zk_job_data</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- my_node-source -->
          
        </div>

        

        
      </div><!-- my_node-method -->

    
      <div id="method-i-optimal_nodes" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">optimal_nodes</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="optimal_nodes-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 891</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">optimal_nodes</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- optimal_nodes-source -->
          
        </div>

        

        
      </div><!-- optimal_nodes-method -->

    
      <div id="method-i-optimal_nodes_hill_climbing" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">optimal_nodes_hill_climbing</span><span
            class="method-args">(job_data, thing_to_optimize)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Hill Climbing Algorithm</p>

<pre># find minimum execution time t1
# find neighbors t0 and t2

# if t0 is too low set it to t1
# if t2 is too high set it to t1

# if no data for either, choose t2
# if no data for t0, choose t0
# if data for both, choose t1</pre>
          

          
          <div class="method-source-code" id="optimal_nodes_hill_climbing-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 908</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">optimal_nodes_hill_climbing</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">thing_to_optimize</span>)
  <span class="ruby-identifier">job_name</span> = <span class="ruby-identifier">get_job_name</span>(<span class="ruby-identifier">job_data</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">thing_to_optimize</span> <span class="ruby-operator">!=</span> <span class="ruby-string">&quot;cost&quot;</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">thing_to_optimize</span> <span class="ruby-operator">!=</span> <span class="ruby-string">&quot;performance&quot;</span>
    <span class="ruby-identifier">abort</span>(<span class="ruby-node">&quot;bad thing to optimize - can be cost or performance but was #{thing_to_optimize}&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">current_data</span> = <span class="ruby-ivar">@jobs</span>[<span class="ruby-identifier">job_name</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">current_data</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">current_data</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;neptune - no job data yet for [#{job_name}]&quot;</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;found job data for [#{job_name}]&quot;</span>)

  <span class="ruby-identifier">min_val</span> = <span class="ruby-constant">INFINITY</span>
  <span class="ruby-identifier">optimal_job</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">current_data</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;current job data is [#{job}]&quot;</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">thing_to_optimize</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;performance&quot;</span>
      <span class="ruby-identifier">my_val</span> = <span class="ruby-identifier">job</span>.<span class="ruby-identifier">total_time</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">thing_to_optimize</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;cost&quot;</span>
      <span class="ruby-identifier">my_val</span> = <span class="ruby-identifier">job</span>.<span class="ruby-identifier">cost</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">abort</span>(<span class="ruby-string">&quot;bad thing to optimize again&quot;</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">my_val</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">min_val</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;found a new minimum - [#{job}]&quot;</span>)
      <span class="ruby-identifier">optimal_job</span> = <span class="ruby-identifier">job</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;minimum is - [#{optimal_job}]&quot;</span>)

  <span class="ruby-identifier">search_space</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@can_run_on&quot;</span>]
  <span class="ruby-identifier">t1</span> = <span class="ruby-identifier">optimal_job</span>.<span class="ruby-identifier">num_nodes</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;optimal right now is t1 = #{t1}&quot;</span>)
  <span class="ruby-identifier">t0</span>, <span class="ruby-identifier">t2</span> = <span class="ruby-identifier">find_neighbors</span>(<span class="ruby-identifier">t1</span>, <span class="ruby-identifier">search_space</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;t1's neighbors are #{t0} and t2 = #{t2}&quot;</span>)

  <span class="ruby-identifier">d0</span> = <span class="ruby-identifier">get_job_data</span>(<span class="ruby-identifier">job_name</span>, <span class="ruby-identifier">t0</span>)
  <span class="ruby-identifier">d2</span> = <span class="ruby-identifier">get_job_data</span>(<span class="ruby-identifier">job_name</span>, <span class="ruby-identifier">t2</span>)

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">t2</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">d0</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">d2</span>.<span class="ruby-identifier">nil?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">t0</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">d0</span>.<span class="ruby-identifier">nil?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">t1</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- optimal_nodes_hill_climbing-source -->
          
        </div>

        

        
      </div><!-- optimal_nodes_hill_climbing-method -->

    
      <div id="method-i-put_input" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">put_input</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="put_input-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">put_input</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-identifier">message</span> = <span class="ruby-identifier">validate_environment</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">message</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">message</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;requesting input&quot;</span>)

  <span class="ruby-identifier">type</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>]

  [<span class="ruby-string">&quot;type&quot;</span>, <span class="ruby-string">&quot;storage&quot;</span>, <span class="ruby-string">&quot;local&quot;</span>, <span class="ruby-string">&quot;remote&quot;</span>].<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-node">&quot;@#{item}&quot;</span>].<span class="ruby-identifier">nil?</span>
      <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;error: #{item} not specified&quot;</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-identifier">input_location</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@remote&quot;</span>]

  <span class="ruby-identifier">local_fs_location</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@local&quot;</span>])

  <span class="ruby-identifier">loop</span> {
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;waiting for file #{local_fs_location} to exist&quot;</span>)
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">local_fs_location</span>)
    <span class="ruby-identifier">sleep</span>(<span class="ruby-value">1</span>)
  }

  <span class="ruby-identifier">msg</span> = <span class="ruby-node">&quot;storing local file #{local_fs_location} with size &quot;</span> <span class="ruby-operator">+</span> 
    <span class="ruby-node">&quot;#{File.size(local_fs_location)}, storing to #{input_location}&quot;</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-identifier">msg</span>)

  <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">ret_val</span> = <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">write_remote_file_from_local_file</span>(<span class="ruby-identifier">input_location</span>, <span class="ruby-identifier">local_fs_location</span>)

  <span class="ruby-comment"># also, if we're running on hbase or hypertable, put a copy of the data</span>
  <span class="ruby-comment"># into HDFS for later processing via mapreduce</span>

  <span class="ruby-identifier">table</span> = <span class="ruby-constant">ENV</span>[<span class="ruby-string">'DATABASE_USED'</span>]

  <span class="ruby-keyword">if</span> [<span class="ruby-string">&quot;hbase&quot;</span>, <span class="ruby-string">&quot;hypertable&quot;</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">table</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">my_node</span>.<span class="ruby-identifier">is_db_master?</span>
      <span class="ruby-identifier">db_master</span> = <span class="ruby-identifier">get_node_with_role</span>(<span class="ruby-string">&quot;db_master&quot;</span>)
      <span class="ruby-identifier">ip</span> = <span class="ruby-identifier">db_master</span>.<span class="ruby-identifier">private_ip</span>
      <span class="ruby-identifier">ssh_key</span> = <span class="ruby-identifier">db_master</span>.<span class="ruby-identifier">ssh_key</span>
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">scp_file</span>(<span class="ruby-identifier">local_fs_location</span>, <span class="ruby-identifier">local_fs_location</span>, <span class="ruby-identifier">ip</span>, <span class="ruby-identifier">ssh_key</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">cmd</span> = <span class="ruby-node">&quot;#{HADOOP_EXECUTABLE} fs -put #{local_fs_location} &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-node">&quot;#{input_location}&quot;</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;putting input in hadoop with command [#{cmd}]&quot;</span>)
    <span class="ruby-identifier">run_on_db_master</span>(<span class="ruby-identifier">cmd</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">ret_val</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- put_input-source -->
          
        </div>

        

        
      </div><!-- put_input-method -->

    
      <div id="method-i-remove_lock_file" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">remove_lock_file</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="remove_lock_file-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 698</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">remove_lock_file</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">shadow</span> = <span class="ruby-identifier">get_node_with_role</span>(<span class="ruby-string">&quot;shadow&quot;</span>)
  <span class="ruby-identifier">shadow_ip</span> = <span class="ruby-identifier">shadow</span>.<span class="ruby-identifier">private_ip</span>
  <span class="ruby-identifier">shadow_key</span> = <span class="ruby-identifier">shadow</span>.<span class="ruby-identifier">ssh_key</span>
  <span class="ruby-identifier">done_running</span> = <span class="ruby-node">&quot;rm #{get_lock_file_path(job_data)}&quot;</span>

  <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">run_remote_command</span>(<span class="ruby-identifier">shadow_ip</span>, <span class="ruby-identifier">done_running</span>, <span class="ruby-identifier">shadow_key</span>, <span class="ruby-constant">NO_OUTPUT</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- remove_lock_file-source -->
          
        </div>

        

        
      </div><!-- remove_lock_file-method -->

    
      <div id="method-i-remove_roles" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">remove_roles</span><span
            class="method-args">(nodes, roles)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="remove_roles-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 870</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">remove_roles</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">roles</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">remove_roles</span>(<span class="ruby-identifier">roles</span>)
    <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">remove_roles_from_node</span>(<span class="ruby-identifier">roles</span>, <span class="ruby-identifier">node</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;[just removed] node at #{node.private_ip} is now #{node.jobs.join(', ')}&quot;</span>)
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- remove_roles-source -->
          
        </div>

        

        
      </div><!-- remove_roles-method -->

    
      <div id="method-i-run_job_on_master" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_job_on_master</span><span
            class="method-args">(master_node, nodes_to_use, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="run_job_on_master-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 605</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_job_on_master</span>(<span class="ruby-identifier">master_node</span>, <span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;run job on master&quot;</span>)
  <span class="ruby-identifier">converted_nodes</span> = <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">convert_location_class_to_array</span>(<span class="ruby-identifier">nodes_to_use</span>)

  <span class="ruby-comment"># in cases where only remote resources are used, we don't acquire a master</span>
  <span class="ruby-comment"># node. therefore, let this node be the master node for this job</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">master_node</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;No master node found - using my node as the master node&quot;</span>)
    <span class="ruby-identifier">master_node</span> = <span class="ruby-identifier">my_node</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">master_node_ip</span> = <span class="ruby-identifier">master_node</span>.<span class="ruby-identifier">private_ip</span>
  <span class="ruby-identifier">nmc</span> = <span class="ruby-constant">NeptuneManagerClient</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">master_node_ip</span>, <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>)

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Dispatching job to #{master_node_ip}&quot;</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">nmc</span>.<span class="ruby-identifier">run_neptune_job</span>(<span class="ruby-identifier">converted_nodes</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Run job result was #{result}&quot;</span>)

  <span class="ruby-identifier">loop</span> {
    <span class="ruby-identifier">shadow</span> = <span class="ruby-identifier">get_node_with_role</span>(<span class="ruby-string">&quot;shadow&quot;</span>)
    <span class="ruby-identifier">lock_file</span> = <span class="ruby-identifier">get_lock_file_path</span>(<span class="ruby-identifier">job_data</span>)
    <span class="ruby-identifier">command</span> = <span class="ruby-node">&quot;ls #{lock_file}; echo $?&quot;</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Shadow's ssh key is #{shadow.ssh_key}&quot;</span>)
    <span class="ruby-identifier">job_is_running</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-node">&quot;ssh -i #{shadow.ssh_key} -o StrictHostkeyChecking=no root@#{shadow.private_ip} '#{command}'&quot;</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Is job running? [#{job_is_running}]&quot;</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_is_running</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">return_val</span> = <span class="ruby-identifier">job_is_running</span>[<span class="ruby-value">-2</span>].<span class="ruby-identifier">chr</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Return value for file #{lock_file} is #{return_val}&quot;</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">return_val</span> <span class="ruby-operator">!=</span> <span class="ruby-string">&quot;0&quot;</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">sleep</span>(<span class="ruby-value">30</span>)
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_job_on_master-source -->
          
        </div>

        

        
      </div><!-- run_job_on_master-method -->

    
      <div id="method-i-run_jobs_in_parallel" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_jobs_in_parallel</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="run_jobs_in_parallel-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_jobs_in_parallel</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Running jobs with optimized path&quot;</span>)
  <span class="ruby-comment"># TODO(cgb): be a bit more intelligent about batch_info</span>
  <span class="ruby-comment"># e.g., it's global_nodes should be the max of all in jobs</span>
  <span class="ruby-identifier">batch_info</span> = <span class="ruby-identifier">jobs</span>[<span class="ruby-value">0</span>]
  <span class="ruby-identifier">touch_lock_file</span>(<span class="ruby-identifier">batch_info</span>)

  <span class="ruby-identifier">nodes_to_use</span> = <span class="ruby-identifier">acquire_nodes</span>(<span class="ruby-identifier">batch_info</span>)

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Nodes to use are [#{nodes_to_use.join(', ')}]&quot;</span>)
  <span class="ruby-identifier">start_job_roles</span>(<span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">batch_info</span>)

  <span class="ruby-identifier">start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>()
  <span class="ruby-identifier">master_node</span> = <span class="ruby-identifier">nodes_to_use</span>.<span class="ruby-identifier">first</span> 
  <span class="ruby-identifier">run_job_on_master</span>(<span class="ruby-identifier">master_node</span>, <span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">jobs</span>)
  <span class="ruby-identifier">end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>()

  <span class="ruby-identifier">stop_job_roles</span>(<span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">batch_info</span>)

  <span class="ruby-identifier">add_timing_info</span>(<span class="ruby-identifier">batch_info</span>, <span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">start_time</span>, <span class="ruby-identifier">end_time</span>)
  <span class="ruby-identifier">cleanup_code</span>(<span class="ruby-identifier">batch_info</span>[<span class="ruby-string">'@code'</span>])
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_jobs_in_parallel-source -->
          
        </div>

        

        
      </div><!-- run_jobs_in_parallel-method -->

    
      <div id="method-i-run_jobs_in_serial" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_jobs_in_serial</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="run_jobs_in_serial-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_jobs_in_serial</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Running jobs with non-optimized path&quot;</span>)
  <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">each_with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Running job number #{i}&quot;</span>)
    <span class="ruby-identifier">touch_lock_file</span>(<span class="ruby-identifier">job_data</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;got run request - #{job_data.inspect}&quot;</span>)

    <span class="ruby-identifier">nodes_to_use</span> = <span class="ruby-identifier">acquire_nodes</span>(<span class="ruby-identifier">job_data</span>)

    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;nodes to use are [#{nodes_to_use.join(', ')}]&quot;</span>)
    <span class="ruby-identifier">start_job_roles</span>(<span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">job_data</span>)

    <span class="ruby-identifier">start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>()
    <span class="ruby-identifier">master_node</span> = <span class="ruby-identifier">nodes_to_use</span>.<span class="ruby-identifier">first</span> 
    <span class="ruby-identifier">run_job_on_master</span>(<span class="ruby-identifier">master_node</span>, <span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">job_data</span>)
    <span class="ruby-identifier">end_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>()

    <span class="ruby-identifier">stop_job_roles</span>(<span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">job_data</span>)

    <span class="ruby-identifier">add_timing_info</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">nodes_to_use</span>, <span class="ruby-identifier">start_time</span>, <span class="ruby-identifier">end_time</span>)
    <span class="ruby-identifier">cleanup_code</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@code'</span>])
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_jobs_in_serial-source -->
          
        </div>

        

        
      </div><!-- run_jobs_in_serial-method -->

    
      <div id="method-i-run_or_delegate_tasks" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_or_delegate_tasks</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="run_or_delegate_tasks-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_or_delegate_tasks</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-identifier">where_tasks_were_run</span> = []

  <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;prejob - this job's data is #{job.inspect}&quot;</span>)
  }

  <span class="ruby-identifier">threads</span> = []
  <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">threads</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">job_data</span> = <span class="ruby-identifier">job</span>.<span class="ruby-identifier">dup</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;This job's data is #{job_data.inspect}&quot;</span>)

    <span class="ruby-comment"># Add in a metadata hash so that any method can add in profiling info,</span>
    <span class="ruby-comment"># with an initial piece of data - when we received the task to run.</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>]
      <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>] = {}
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'received_task_at'</span>] = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>.<span class="ruby-identifier">to_f</span>
    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>][<span class="ruby-string">'queue_pop_time'</span>] = <span class="ruby-value">0.0</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@run_local'</span>]
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;running job with data #{job_data.inspect} locally&quot;</span>)
      <span class="ruby-identifier">run_task</span>(<span class="ruby-identifier">job_data</span>)
      <span class="ruby-identifier">where_tasks_were_run</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">RUN_LOCALLY</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">engine</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@engine'</span>]
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">engine</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;executor&quot;</span>)
      <span class="ruby-identifier">run_via_executor</span>(<span class="ruby-identifier">engine</span>, <span class="ruby-identifier">job_data</span>)
      <span class="ruby-identifier">where_tasks_were_run</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">RUN_VIA_EXECUTOR</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">run_via_engine</span>(<span class="ruby-identifier">engine</span>, <span class="ruby-identifier">job_data</span>)
      <span class="ruby-identifier">where_tasks_were_run</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">RUN_VIA_REMOTE_ENGINE</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>
    }
  }

  <span class="ruby-identifier">threads</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">t</span>.<span class="ruby-identifier">join</span> }
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">where_tasks_were_run</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_or_delegate_tasks-source -->
          
        </div>

        

        
      </div><!-- run_or_delegate_tasks-method -->

    
      <div id="method-i-run_task" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_task</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="run_task-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 386</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_task</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">dir</span> = <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">create_temp_dir</span>()
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">copy_code_and_inputs_to_dir</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-identifier">output</span>, <span class="ruby-identifier">error</span> = <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">run_code</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">dir</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">write_babel_outputs</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">error</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">cleanup</span>(<span class="ruby-identifier">dir</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_task-source -->
          
        </div>

        

        
      </div><!-- run_task-method -->

    
      <div id="method-i-run_via_engine" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_via_engine</span><span
            class="method-args">(engine, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks may also be run via remote engines - that is, they may have an
internal queue but definitely have a remote executor that we can blindly
push the task to and let it take care of.</p>
          

          
          <div class="method-source-code" id="run_via_engine-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_via_engine</span>(<span class="ruby-identifier">engine</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;running job with data #{job_data.inspect} via a remote engine&quot;</span>)

  <span class="ruby-comment"># When pushing jobs to AppScale's push queues, we need to know where the</span>
  <span class="ruby-comment"># app is located (via the login node's IP address) and the UserAppServer's</span>
  <span class="ruby-comment"># IP address, so pass that info along.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">engine</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;appscale-push-q&quot;</span>
    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@login_ip'</span>] = <span class="ruby-identifier">get_login</span>.<span class="ruby-identifier">public_ip</span>
    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@uaserver_ip'</span>] = <span class="ruby-ivar">@userappserver_public_ip</span>
    <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@secret'</span>] = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>()
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Adding info for AppScale push queues - &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-node">&quot;job data is now #{job_data.inspect}&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">e</span> = <span class="ruby-constant">EngineFactory</span>.<span class="ruby-identifier">get_engine</span>(<span class="ruby-identifier">engine</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">e</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">job_data</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_via_engine-source -->
          
        </div>

        

        
      </div><!-- run_via_engine-method -->

    
      <div id="method-i-run_via_executor" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">run_via_executor</span><span
            class="method-args">(engine, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Tasks can be run via our task executor, which will run tasks within
AppScale and store task data in a queue service, which may not be local to
AppScale.</p>
          

          
          <div class="method-source-code" id="run_via_executor-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run_via_executor</span>(<span class="ruby-identifier">engine</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;running job with data #{job_data.inspect} via executor&quot;</span>)
  <span class="ruby-identifier">q</span> = <span class="ruby-constant">QueueFactory</span>.<span class="ruby-identifier">get_queue</span>(<span class="ruby-identifier">engine</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">credentials</span> = <span class="ruby-identifier">q</span>.<span class="ruby-identifier">get_creds</span>()
  <span class="ruby-identifier">queue_and_creds</span> = {<span class="ruby-identifier">engine</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">credentials</span>}

  <span class="ruby-comment"># the user has to tell us the maximum number of machines that can be used</span>
  <span class="ruby-comment"># for babel slaves, so update that info in ZooKeeper</span>
  <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">set_max_machines_for_babel_slaves</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@global_max_nodes'</span>])

  <span class="ruby-comment"># since the same queue / credentials can be used repeatedly, don't keep</span>
  <span class="ruby-comment"># adding the same queue info over and over again</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@queues_to_read</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">queue_and_creds</span>)
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;not adding queue and creds #{queue_and_creds.inspect} &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-string">&quot;to @queues_to_read - it's already in the list&quot;</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;adding queue and creds #{queue_and_creds.inspect} to &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-string">&quot;@queues_to_read&quot;</span>)
    <span class="ruby-ivar">@queues_to_read</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">queue_and_creds</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;@queues_to_read now contains &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;[#{@queues_to_read.join(', ')}]&quot;</span>)
  <span class="ruby-identifier">q</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">job_data</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- run_via_executor-source -->
          
        </div>

        

        
      </div><!-- run_via_executor-method -->

    
      <div id="method-i-set_acl" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">set_acl</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="set_acl-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_acl</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-identifier">message</span> = <span class="ruby-identifier">validate_environment</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">message</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">message</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;no error&quot;</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;setting acl&quot;</span>)

  <span class="ruby-identifier">type</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>]

  <span class="ruby-identifier">new_acl</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@acl&quot;</span>]

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_acl</span> <span class="ruby-operator">!=</span> <span class="ruby-string">&quot;public&quot;</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">new_acl</span> <span class="ruby-operator">!=</span> <span class="ruby-string">&quot;private&quot;</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: new acl is neither public nor private&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">output_location</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@output&quot;</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">output_location</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: output not specified&quot;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], <span class="ruby-identifier">job_data</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">does_file_exist?</span>(<span class="ruby-identifier">output_location</span>)
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">set_acl</span>(<span class="ruby-identifier">output_location</span>, <span class="ruby-identifier">new_acl</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;error: output does not exist&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- set_acl-source -->
          
        </div>

        

        
      </div><!-- set_acl-method -->

    
      <div id="method-i-spawn_babel_slaves" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">spawn_babel_slaves</span><span
            class="method-args">(num_of_waiting_tasks)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>A Babel master can call this method to add more workers (Babel slaves) to
the system as needed.</p>
          

          
          <div class="method-source-code" id="spawn_babel_slaves-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 664</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">spawn_babel_slaves</span>(<span class="ruby-identifier">num_of_waiting_tasks</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;spawning workers to handle #{num_of_waiting_tasks} tasks&quot;</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_cloud?</span>
    <span class="ruby-identifier">instance_type</span> = <span class="ruby-string">&quot;m1.large&quot;</span>
    <span class="ruby-comment">#instance_type = &quot;m2.4xlarge&quot;</span>
    <span class="ruby-identifier">cores_per_machine</span> = <span class="ruby-constant">INSTANCE_CPU_INFO</span>[<span class="ruby-identifier">instance_type</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">instance_type</span> = <span class="ruby-string">&quot;m1.large&quot;</span>
    <span class="ruby-identifier">cores_per_machine</span> = <span class="ruby-value">2</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Using #{cores_per_machine} cores/machine&quot;</span>)

  <span class="ruby-comment"># First, calculate how many machines we would need to run all the tasks</span>
  <span class="ruby-comment"># as fast as possible, by running one task per core.</span>
  <span class="ruby-identifier">optimal_num_of_vms</span> = (<span class="ruby-identifier">num_of_waiting_tasks</span> <span class="ruby-operator">/</span> <span class="ruby-constant">Float</span>(<span class="ruby-identifier">cores_per_machine</span>)).<span class="ruby-identifier">ceil</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Will run #{num_of_waiting_tasks} on &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;#{optimal_num_of_vms} VMs&quot;</span>)

  <span class="ruby-comment"># The optimal number of VMs is optimal with respect to performance, but</span>
  <span class="ruby-comment"># is not optimal with respect to cost. As the user has told us what the</span>
  <span class="ruby-comment"># maximum number of machines they want to run are, grab that number and</span>
  <span class="ruby-comment"># compare the two to see how many machines we should actually acquire.</span>
  <span class="ruby-identifier">user_num_of_vms</span> = <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">get_max_machines_for_babel_slaves</span>()

  <span class="ruby-identifier">total_num_of_vms_needed</span> = [<span class="ruby-identifier">optimal_num_of_vms</span>, <span class="ruby-identifier">user_num_of_vms</span>].<span class="ruby-identifier">min</span>
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;For #{num_of_waiting_tasks} tasks, the optimal number of &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;VMs to use is #{optimal_num_of_vms} VMs, while the user specified that &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;no more than #{user_num_of_vms} VMs - using #{total_num_of_vms_needed} &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">&quot;total VMs&quot;</span>)

  <span class="ruby-comment"># A previous invocation of this function may have already spawned up</span>
  <span class="ruby-comment"># babel slaves, so to obey the maximum that the user has given us, we have to</span>
  <span class="ruby-comment"># subtract any already running babel slaves out of the value calculated above.</span>
  <span class="ruby-identifier">babel_slaves_already_running</span> = <span class="ruby-value">0</span>
  <span class="ruby-ivar">@nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">babel_slaves_already_running</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">is_babel_slave?</span>
  }

  <span class="ruby-identifier">num_of_vms_needed</span> = <span class="ruby-identifier">total_num_of_vms_needed</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">babel_slaves_already_running</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">num_of_vms_needed</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{babel_slaves_already_running} VMs are already running &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-node">&quot;as babel slaves, so we still need to spawn #{num_of_vms_needed} VMs&quot;</span>)

    <span class="ruby-comment"># Include rabbitmq_slave in here since we want to always be able to point</span>
    <span class="ruby-comment"># our RabbitMQ client to localhost to get tasks</span>
    <span class="ruby-identifier">nodes_needed</span> = []
    <span class="ruby-identifier">num_of_vms_needed</span>.<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">nodes_needed</span> <span class="ruby-operator">&lt;&lt;</span> [<span class="ruby-string">&quot;rabbitmq_slave&quot;</span>, <span class="ruby-string">&quot;babel_slave&quot;</span>]
    }

    <span class="ruby-identifier">start_new_roles_on_nodes</span>(<span class="ruby-identifier">nodes_needed</span>, <span class="ruby-identifier">instance_type</span>,
      <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>())
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{babel_slaves_already_running} VMs are already &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-node">&quot;running, and as can only have a maximum of #{num_of_vms_needed}, we &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-string">&quot;don't need to acquire more babel slaves right now&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- spawn_babel_slaves-source -->
          
        </div>

        

        
      </div><!-- spawn_babel_slaves-method -->

    
      <div id="method-i-spawn_nodes_for_neptune-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">spawn_nodes_for_neptune?</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="spawn_nodes_for_neptune-3F-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 719</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">spawn_nodes_for_neptune?</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;neptune_info = #{job_data}&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@nodes_to_use&quot;</span>].<span class="ruby-identifier">nil?</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- spawn_nodes_for_neptune-3F-source -->
          
        </div>

        

        
      </div><!-- spawn_nodes_for_neptune-3F-method -->

    
      <div id="method-i-start" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">start</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="start-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start</span>()
  <span class="ruby-identifier">initialize_zookeeper_connection</span>()
  <span class="ruby-comment">#manage_virtual_machines()</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- start-source -->
          
        </div>

        

        
      </div><!-- start-method -->

    
      <div id="method-i-start_babel_master" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">start_babel_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>The nodes that runs as a babel_master is a master in the system. It decides
when to spawn new workers, and how many to spawn, based on the number of
tasks waiting to be executed in all queues.</p>
          

          
          <div class="method-source-code" id="start_babel_master-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start_babel_master</span>()
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{my_node.private_ip} is starting babel master&quot;</span>)

  <span class="ruby-keyword">while</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@kill_sig_received</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">queues</span> = <span class="ruby-identifier">get_queues_from_shadow</span>()
    <span class="ruby-identifier">num_of_waiting_tasks</span> = <span class="ruby-identifier">get_length_of_all_queues</span>(<span class="ruby-identifier">queues</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">num_of_waiting_tasks</span>.<span class="ruby-identifier">zero?</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;all queues are empty - waiting for tasks to arrive&quot;</span>)
      <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">sleep</span>(<span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">spawn_babel_slaves</span>(<span class="ruby-identifier">num_of_waiting_tasks</span>)
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;workers spawned - waiting for them to run tasks&quot;</span>)
      <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">sleep</span>(<span class="ruby-constant">TIME_FOR_NEW_NODES_TO_GET_TASKS</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- start_babel_master-source -->
          
        </div>

        

        
      </div><!-- start_babel_master-method -->

    
      <div id="method-i-start_babel_slave" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">start_babel_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Nodes that run as babel_slaves are workers in the system. They ask the
master what queues tasks are stored on, and try to execute a configurable
number of tasks at a time.</p>
          

          
          <div class="method-source-code" id="start_babel_slave-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 340</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start_babel_slave</span>()
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{my_node.private_ip} is starting babel slave&quot;</span>)

  <span class="ruby-identifier">time_spent_idle</span> = <span class="ruby-value">0.0</span>
  <span class="ruby-identifier">loop</span> {
    <span class="ruby-identifier">queues</span> = <span class="ruby-identifier">get_queues_from_shadow</span>()
    <span class="ruby-identifier">cores_per_machine</span> = <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_num_cpus</span>()
    <span class="ruby-identifier">tasks</span> = <span class="ruby-identifier">get_n_items_of_work</span>(<span class="ruby-identifier">cores_per_machine</span>, <span class="ruby-identifier">queues</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">tasks</span>.<span class="ruby-identifier">length</span>.<span class="ruby-identifier">zero?</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">time_spent_idle</span> <span class="ruby-operator">&gt;</span> <span class="ruby-constant">MAX_IDLE_TIME</span>
        <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Spent too much time idle - reverting to open for now&quot;</span>)
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;no tasks found, waiting for more to arrive&quot;</span>)
        <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">sleep</span>(<span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>)
        <span class="ruby-identifier">time_spent_idle</span> <span class="ruby-operator">+=</span> <span class="ruby-constant">TIME_TO_WAIT_FOR_NEW_TASKS</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{tasks.length} tasks found, executing&quot;</span>)
      <span class="ruby-identifier">execute_multiple_tasks</span>(<span class="ruby-identifier">tasks</span>)
      <span class="ruby-identifier">time_spent_idle</span> = <span class="ruby-value">0.0</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Removing babel slave roles from this node&quot;</span>)
  <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">lock_and_run</span> {
    <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">remove_roles_from_node</span>([<span class="ruby-string">&quot;rabbitmq_slave, &quot;</span><span class="ruby-string">&quot;babel_slave&quot;</span>], 
      <span class="ruby-identifier">my_node</span>)
    <span class="ruby-constant">ZKInterface</span>.<span class="ruby-identifier">add_roles_to_node</span>([<span class="ruby-string">&quot;open&quot;</span>], <span class="ruby-identifier">my_node</span>)
  }
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;Finished removing roles via ZooKeeper&quot;</span>)
  }
<span class="ruby-keyword">end</span></pre>
          </div><!-- start_babel_slave-source -->
          
        </div>

        

        
      </div><!-- start_babel_slave-method -->

    
      <div id="method-i-start_job" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">start_job</span><span
            class="method-args">(jobs, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="start_job-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start_job</span>(<span class="ruby-identifier">jobs</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">jobs</span> = [<span class="ruby-identifier">jobs</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {
    <span class="ruby-identifier">dispatch_jobs</span>(<span class="ruby-identifier">jobs</span>)
  }

  <span class="ruby-keyword">return</span> <span class="ruby-constant">JOB_IS_RUNNING</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- start_job-source -->
          
        </div>

        

        
      </div><!-- start_job-method -->

    
      <div id="method-i-start_job_roles" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">start_job_roles</span><span
            class="method-args">(nodes, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="start_job_roles-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 552</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start_job_roles</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;job - start&quot;</span>)

  <span class="ruby-comment"># if all the resources are remotely owned, we can't add roles to</span>
  <span class="ruby-comment"># them, so don't</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;no nodes to add roles to, returning...&quot;</span>)
    <span class="ruby-keyword">return</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">master_role</span>, <span class="ruby-identifier">slave_role</span> = <span class="ruby-identifier">get_node_roles</span>(<span class="ruby-identifier">job_data</span>)

  <span class="ruby-identifier">other_nodes</span> = <span class="ruby-identifier">nodes</span> <span class="ruby-operator">-</span> [<span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">first</span>]
  <span class="ruby-identifier">add_roles_and_wait</span>(<span class="ruby-identifier">other_nodes</span>, <span class="ruby-identifier">slave_role</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">other_nodes</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">other_nodes</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># TODO: prettify me</span>
  <span class="ruby-identifier">other_nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">add_roles</span>(<span class="ruby-identifier">slave_role</span>)
  }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">master_node</span> = <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">first</span>
  <span class="ruby-identifier">master_node_ip</span> = <span class="ruby-identifier">master_node</span>.<span class="ruby-identifier">private_ip</span>

  <span class="ruby-identifier">master_acc</span> = <span class="ruby-constant">AppControllerClient</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">master_node_ip</span>, <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>)
  <span class="ruby-identifier">master_acc</span>.<span class="ruby-identifier">add_role</span>(<span class="ruby-identifier">master_role</span>)

  <span class="ruby-comment"># finally, update our local copy of what the master is doing</span>
  <span class="ruby-identifier">master_node</span>.<span class="ruby-identifier">add_roles</span>(<span class="ruby-identifier">master_role</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- start_job_roles-source -->
          
        </div>

        

        
      </div><!-- start_job_roles-method -->

    
      <div id="method-i-stop_babel_master" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">stop_babel_master</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="stop_babel_master-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 376</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">stop_babel_master</span>()
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{my_node.private_ip} is stopping babel master&quot;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- stop_babel_master-source -->
          
        </div>

        

        
      </div><!-- stop_babel_master-method -->

    
      <div id="method-i-stop_babel_slave" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">stop_babel_slave</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="stop_babel_slave-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/babel_helper.rb, line 381</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">stop_babel_slave</span>()
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;#{my_node.private_ip} is stopping babel slave&quot;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- stop_babel_slave-source -->
          
        </div>

        

        
      </div><!-- stop_babel_slave-method -->

    
      <div id="method-i-stop_job_roles" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">stop_job_roles</span><span
            class="method-args">(nodes, job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="stop_job_roles-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 642</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">stop_job_roles</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">job_data</span>)
  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;job - stop&quot;</span>)

  <span class="ruby-comment"># if all the resources are remotely owned, we can't add roles to</span>
  <span class="ruby-comment"># them, so don't</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-string">&quot;no nodes to add roles to, returning...&quot;</span>)
    <span class="ruby-keyword">return</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">master_role</span>, <span class="ruby-identifier">slave_role</span> = <span class="ruby-identifier">get_node_roles</span>(<span class="ruby-identifier">job_data</span>)

  <span class="ruby-identifier">master_node</span> = <span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">first</span>
  <span class="ruby-identifier">master_node_ip</span> = <span class="ruby-identifier">master_node</span>.<span class="ruby-identifier">private_ip</span>
  <span class="ruby-identifier">master_node</span>.<span class="ruby-identifier">remove_roles</span>(<span class="ruby-identifier">master_role</span>)

  <span class="ruby-identifier">master_acc</span> = <span class="ruby-constant">AppControllerClient</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">master_node_ip</span>, <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">get_secret</span>)
  <span class="ruby-identifier">master_acc</span>.<span class="ruby-identifier">remove_role</span>(<span class="ruby-identifier">master_role</span>)

  <span class="ruby-identifier">other_nodes</span> = <span class="ruby-identifier">nodes</span> <span class="ruby-operator">-</span> [<span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">first</span>]
  <span class="ruby-identifier">remove_roles</span>(<span class="ruby-identifier">other_nodes</span>, <span class="ruby-identifier">slave_role</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">other_nodes</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">other_nodes</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># TODO: prettify me</span>
    <span class="ruby-identifier">other_nodes</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">remove_roles</span>(<span class="ruby-identifier">slave_role</span>)
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- stop_job_roles-source -->
          
        </div>

        

        
      </div><!-- stop_job_roles-method -->

    
      <div id="method-i-touch_lock_file" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">touch_lock_file</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="touch_lock_file-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 691</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">touch_lock_file</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@job_id&quot;</span>] = <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-value">1000000</span>)
  <span class="ruby-identifier">touch_lock_file</span> = <span class="ruby-node">&quot;touch #{get_lock_file_path(job_data)}&quot;</span>
  <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-identifier">touch_lock_file</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- touch_lock_file-source -->
          
        </div>

        

        
      </div><!-- touch_lock_file-method -->

    
      <div id="method-i-uncompress_file" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">uncompress_file</span><span
            class="method-args">(tar)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="uncompress_file-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1042</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">uncompress_file</span>(<span class="ruby-identifier">tar</span>)
  <span class="ruby-keyword">unless</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exists?</span>(<span class="ruby-identifier">tar</span>)
    <span class="ruby-identifier">abort</span>(<span class="ruby-node">&quot;The file #{tar} didn't exist, so we couldn't uncompress it.&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">tar</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">%r.tar.gz\Z/</span>)
    <span class="ruby-identifier">dir</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">tar</span>)
    <span class="ruby-constant">HelperFunctions</span>.<span class="ruby-identifier">shell</span>(<span class="ruby-node">&quot;cd #{dir}; tar zxvf #{tar}&quot;</span>)
    <span class="ruby-keyword">return</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># TODO: add other extension types: zip, bzip2, tar, gz</span>
  <span class="ruby-comment">#ext = File.extname(tar)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#case ext</span>
  <span class="ruby-comment">#when &quot;.&quot;</span>
  <span class="ruby-comment">#end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- uncompress_file-source -->
          
        </div>

        

        
      </div><!-- uncompress_file-method -->

    
      <div id="method-i-valid_secret-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">valid_secret?</span><span
            class="method-args">(secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="valid_secret-3F-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">secret</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@secret</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- valid_secret-3F-source -->
          
        </div>

        

        
      </div><!-- valid_secret-3F-method -->

    
      <div id="method-i-validate_environment" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">validate_environment</span><span
            class="method-args">(job_data, secret)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="validate_environment-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 671</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">validate_environment</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_SECRET_MSG</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">valid_secret?</span>(<span class="ruby-identifier">secret</span>)
  <span class="ruby-comment">#return JOB_IN_PROGRESS if lock_file_exists?(job_data)</span>
  <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_TYPE_MSG</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">JOB_LIST</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>])

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&quot;mapreduce&quot;</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-constant">DBS_W_HADOOP</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-constant">ENV</span>[<span class="ruby-string">'DATABASE_USED'</span>])
      <span class="ruby-keyword">return</span> <span class="ruby-constant">BAD_TABLE_MSG</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;no error&quot;</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- validate_environment-source -->
          
        </div>

        

        
      </div><!-- validate_environment-method -->

    
      <div id="method-i-wait_for_allotted_time" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">wait_for_allotted_time</span><span
            class="method-args">(job_data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>When spawning up nodes to use for AppScale, we force the user to specify
how long the nodes should live for. This method simply waits that long.
TODO(cgb): What about cases when the nodes should last forever?</p>
          

          
          <div class="method-source-code" id="wait_for_allotted_time-source">
            <pre><span class="ruby-comment"># File Neptune/lib/job_types/appscale_helper.rb, line 35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">wait_for_allotted_time</span>(<span class="ruby-identifier">job_data</span>)
  <span class="ruby-identifier">start_time</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
  <span class="ruby-identifier">time_allotted</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@time_needed_for&quot;</span>])
  <span class="ruby-identifier">item_spawned</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@add_component&quot;</span>]

  <span class="ruby-identifier">loop</span> {
    <span class="ruby-identifier">now</span> = <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span>
    <span class="ruby-identifier">time_elapsed</span> = <span class="ruby-identifier">now</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">start_time</span>
    <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;time elapsed for #{item_spawned} so far is&quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-node">&quot; #{time_elapsed}, time allotted is #{time_allotted}&quot;</span>)
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">time_elapsed</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">time_allotted</span>
    <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">sleep</span>(<span class="ruby-value">60</span>)
  }

  <span class="ruby-identifier">remove_lock_file</span>(<span class="ruby-identifier">job_data</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- wait_for_allotted_time-source -->
          
        </div>

        

        
      </div><!-- wait_for_allotted_time-method -->

    
      <div id="method-i-write_job_output" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write_job_output</span><span
            class="method-args">(job_data, output_location)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="write_job_output-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 997</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">write_job_output</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">output_location</span>)
  <span class="ruby-identifier">write_job_output_handler</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">output_location</span>, <span class="ruby-identifier">is_file</span>=<span class="ruby-keyword">true</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- write_job_output-source -->
          
        </div>

        

        
      </div><!-- write_job_output-method -->

    
      <div id="method-i-write_job_output_handler" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write_job_output_handler</span><span
            class="method-args">(job_data, output, is_file)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="write_job_output_handler-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1007</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">write_job_output_handler</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">output</span>, <span class="ruby-identifier">is_file</span>)
  <span class="ruby-identifier">db_location</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@output&quot;</span>]
  <span class="ruby-identifier">job_type</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@type&quot;</span>]
  <span class="ruby-identifier">storage</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@storage&quot;</span>]

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;[#{job_type}] Job done - Writing output to &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-node">&quot;#{db_location}, backed by #{storage}&quot;</span>)
  <span class="ruby-identifier">datastore</span> = <span class="ruby-constant">DatastoreFactory</span>.<span class="ruby-identifier">get_datastore</span>(<span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@storage'</span>], 
    <span class="ruby-identifier">job_data</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_file</span>
    <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">write_remote_file_from_local_file</span>(<span class="ruby-identifier">db_location</span>, <span class="ruby-identifier">output</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">datastore</span>.<span class="ruby-identifier">write_remote_file_from_string</span>(<span class="ruby-identifier">db_location</span>, <span class="ruby-identifier">output</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NeptuneManager</span>.<span class="ruby-identifier">log</span>(<span class="ruby-node">&quot;Done writing output to #{db_location}&quot;</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- write_job_output_handler-source -->
          
        </div>

        

        
      </div><!-- write_job_output_handler-method -->

    
      <div id="method-i-write_job_output_str" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write_job_output_str</span><span
            class="method-args">(job_data, string)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          
          

          
          <div class="method-source-code" id="write_job_output_str-source">
            <pre><span class="ruby-comment"># File Neptune/neptune_manager.rb, line 1002</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">write_job_output_str</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">string</span>)
  <span class="ruby-identifier">write_job_output_handler</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">string</span>, <span class="ruby-identifier">is_file</span>=<span class="ruby-keyword">false</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- write_job_output_str-source -->
          
        </div>

        

        
      </div><!-- write_job_output_str-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

